{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Plugins else Miscellaneous plugins accum : Simple accumulator of scalar values atstop : Schedule an instrument at the end of the current instrument bisect : Returns the fractional index of a value within a sorted array / tab crackle : generates noise based on a chaotic equation deref : Dereference a previously created reference to a variable detectsilence : Detect when input falls below an amplitude threshold diode_ringmod : A ring modulator with optional non-linearities extendarray : Extend one array with the contents of a second array, in place fileexists : Returns 1 if a file exists and can be read findarray : Find an element in an array frac2int : Convert the fractional part of a number into an integer ftfill : create a table and fill it with values (like fillarray but for f-tables) ftfind : Find an element in a table ftnew : creates a new table of a given size ftsetparams : Set metadata parameters of a table, as if it was loaded via GEN1 initerror : Throws an error message at init interp1d : Interpolate between elements of an array/table lfnoise : low frequency, band-limited noise linenv : A triggerable linear envelope with sustain segment loadnpy : Load an array (of any number of dimensions) saved as a .npy file memview : Create a view into a table or another array panstereo : Stereo signal balancer perlin3 : gradient noise sound generator pread : Read pfield values from any active instrument instance pwrite : Modify pfield values of an active instrument instance ramptrig : A triggerable ramp between 0 and 1 ref : Get a reference to a variable refvalid : Queries if a reference is valid schmitt : A schmitt trigger (a comparator with hysteresis). setslice : Set a slice of an array to a given value sigmdrive : Analog \"soft clipping\" distortion by applying non-linear transfer functions. standardchaos : Standard map chaotic generator throwerror : Throws an error message at performance or init uniqinstance : Return an fractional instrument number which is not in use zeroarray : Zero all elements in an array pathtools Cross-platform path handling and string opcodes findFileInPath : Find a file inside the search paths of the csound environment getEnvVar : Get the value of an environment variable pathAbsolute : Returns the absolute path of a file pathIsAbsolute : Returns 1 if the path of a file is absolute pathJoin : Join two parts of a path according to the current platform pathNative : Convert a path to its native version pathSplit : Split a path into directory and basename pathSplitExt : Split a path into prefix and extension pathSplitExtk : Split a path into prefix and extension at performance time pathSplitk : Split a path into directory and basename at perf-time scriptDir : Get the directory of the loaded orc/csd file strjoin : Concatenate any number of strings strsplit : Split a string at a given separator sysPlatform : Get a string description of the current system platform","title":"Plugins"},{"location":"index.html#plugins","text":"","title":"Plugins"},{"location":"index.html#else","text":"Miscellaneous plugins accum : Simple accumulator of scalar values atstop : Schedule an instrument at the end of the current instrument bisect : Returns the fractional index of a value within a sorted array / tab crackle : generates noise based on a chaotic equation deref : Dereference a previously created reference to a variable detectsilence : Detect when input falls below an amplitude threshold diode_ringmod : A ring modulator with optional non-linearities extendarray : Extend one array with the contents of a second array, in place fileexists : Returns 1 if a file exists and can be read findarray : Find an element in an array frac2int : Convert the fractional part of a number into an integer ftfill : create a table and fill it with values (like fillarray but for f-tables) ftfind : Find an element in a table ftnew : creates a new table of a given size ftsetparams : Set metadata parameters of a table, as if it was loaded via GEN1 initerror : Throws an error message at init interp1d : Interpolate between elements of an array/table lfnoise : low frequency, band-limited noise linenv : A triggerable linear envelope with sustain segment loadnpy : Load an array (of any number of dimensions) saved as a .npy file memview : Create a view into a table or another array panstereo : Stereo signal balancer perlin3 : gradient noise sound generator pread : Read pfield values from any active instrument instance pwrite : Modify pfield values of an active instrument instance ramptrig : A triggerable ramp between 0 and 1 ref : Get a reference to a variable refvalid : Queries if a reference is valid schmitt : A schmitt trigger (a comparator with hysteresis). setslice : Set a slice of an array to a given value sigmdrive : Analog \"soft clipping\" distortion by applying non-linear transfer functions. standardchaos : Standard map chaotic generator throwerror : Throws an error message at performance or init uniqinstance : Return an fractional instrument number which is not in use zeroarray : Zero all elements in an array","title":"else"},{"location":"index.html#pathtools","text":"Cross-platform path handling and string opcodes findFileInPath : Find a file inside the search paths of the csound environment getEnvVar : Get the value of an environment variable pathAbsolute : Returns the absolute path of a file pathIsAbsolute : Returns 1 if the path of a file is absolute pathJoin : Join two parts of a path according to the current platform pathNative : Convert a path to its native version pathSplit : Split a path into directory and basename pathSplitExt : Split a path into prefix and extension pathSplitExtk : Split a path into prefix and extension at performance time pathSplitk : Split a path into directory and basename at perf-time scriptDir : Get the directory of the loaded orc/csd file strjoin : Concatenate any number of strings strsplit : Split a string at a given separator sysPlatform : Get a string description of the current system platform","title":"pathtools"},{"location":"opcodes/index.html","text":"Put the manual pages of each opcode in this folder, in markdown format, with the format {opcodename}.md","title":"Index"},{"location":"opcodes/accum.html","text":"accum Abstract Simple accumulator of scalar values Description accum can be used together with changed , changed2 , metro , etc, to convert a binary trigger to an incremental one. Incremental triggers are used by many opcodes ( printf , for example), so by doing accum(changed(kvar)) it is possible to use binary triggers wherever an incremental trigger is expected. accum outputs its current value and increments it afterwords. Syntax k out a ccum k step , i nitial = 0 , k reset = 0 a out a ccum k step , i nitial = 0 , k reset = 0 Arguments kstep : the step to add. This value will be added at each iteration (at each k-cycle for accum:k and at each sample for accum:a ) initial : initial value of the accumulator kreset : if 1, the accummulator is reset to the initial value Output kout : accumulated value Execution Time Init Examples k out a ccum 1 , 0 ; outputs 0, 1, 2, 3, 4... ; Play a sample with variable speed, stop the event when finished a index a ccum 1 k speed = linseg : k ( 0.5 , i len , 2 ) i len = ftlen ( i ft ) a index *= k speed a sig table3 a index , i ft if a index [ 0 ] >= i len - ( ksmps * k speed ) then turnoff endif i fade = 1 / ksmps out a sig * linsegr ( 0 , i fade , 1 , i fade , 0 ) < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > instr 1 k x linseg 0 , p3 , 1 printf \"kx= %f \\n \" , a ccum ( changed ( k x )), k x ; the same without accum would only print the first time, ; since changed would return always 1 but printf expects an ever ; increasing trigger endin </ CsInstruments > < CsScore > i 1 0 0.1 </ CsScore > </ CsoundSynthesizer > See also metro changed trighold printf Credits Eduardo Moguillansky, 2019","title":"accum"},{"location":"opcodes/accum.html#accum","text":"","title":"accum"},{"location":"opcodes/accum.html#abstract","text":"Simple accumulator of scalar values","title":"Abstract"},{"location":"opcodes/accum.html#description","text":"accum can be used together with changed , changed2 , metro , etc, to convert a binary trigger to an incremental one. Incremental triggers are used by many opcodes ( printf , for example), so by doing accum(changed(kvar)) it is possible to use binary triggers wherever an incremental trigger is expected. accum outputs its current value and increments it afterwords.","title":"Description"},{"location":"opcodes/accum.html#syntax","text":"k out a ccum k step , i nitial = 0 , k reset = 0 a out a ccum k step , i nitial = 0 , k reset = 0","title":"Syntax"},{"location":"opcodes/accum.html#arguments","text":"kstep : the step to add. This value will be added at each iteration (at each k-cycle for accum:k and at each sample for accum:a ) initial : initial value of the accumulator kreset : if 1, the accummulator is reset to the initial value","title":"Arguments"},{"location":"opcodes/accum.html#output","text":"kout : accumulated value","title":"Output"},{"location":"opcodes/accum.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/accum.html#examples","text":"k out a ccum 1 , 0 ; outputs 0, 1, 2, 3, 4... ; Play a sample with variable speed, stop the event when finished a index a ccum 1 k speed = linseg : k ( 0.5 , i len , 2 ) i len = ftlen ( i ft ) a index *= k speed a sig table3 a index , i ft if a index [ 0 ] >= i len - ( ksmps * k speed ) then turnoff endif i fade = 1 / ksmps out a sig * linsegr ( 0 , i fade , 1 , i fade , 0 ) < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > instr 1 k x linseg 0 , p3 , 1 printf \"kx= %f \\n \" , a ccum ( changed ( k x )), k x ; the same without accum would only print the first time, ; since changed would return always 1 but printf expects an ever ; increasing trigger endin </ CsInstruments > < CsScore > i 1 0 0.1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/accum.html#see-also","text":"metro changed trighold printf","title":"See also"},{"location":"opcodes/accum.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/atstop.html","text":"atstop Abstract Schedule an instrument at the end of the current instrument Description atstop can be used to schedule an instrument event as the last action of a given instrument, during the process of being deallocated. This can be used to notify when the note has actually stopped, or to schedule a chain of events, free any table or dict allocated, etc. The advantage over the release opcode is that atstop is guaranteed to be run after the note has stopped, so there is no danger in deallocating resources being used by this note, there are no conflicts with release envelopes, etc. If any k-variables are passed to the scheduled instr these will reflect the changes at the end of the instr. Release time vs deinit time The event is not scheduled at release time (see below \"Release time vs Deinit time\") but at the moment the note is freed. Release time is when the note is within its release phase , which will only happen if the note has an envelope with a release segment (like linsegr ), or if it has setup extra time with xtratim . The opcode release can be used to query if the current note is being released. The instrument keeps running in release phase as long as the release part of the envelope is finished or the extra time allocated via xtratim is through. Deinit time is the moment the note is actually being freed, so the instrument is not running anymore at this point. Syntax a tstop i nstrnum [, i delay = 0 , i dur =- 1 , p4 , p5 , ... ] a tstop S instrname [, i delay = 0 , i dur =- 1 , p4 , p5 , ... ] Arguments instrnum / Sintrname : the number or the name of the instr to be scheduled idelay : the time offset after the stop time of this note to start this instrument idur : the duration of the event p4 , p5 , ...: any other p-arguments, as used with similar opcodes like schedule , event , etc. They can be any i-, k- or S- variable. The scheduled instr will access them, as p-args. Execution Time Init Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* # This is the example file for the atstop opcode atstop schedules an instrument at the end of the note This might be useful to notify that a note stopped, or to schedule a chain of notes, etc. NB: the scheduled event is NOT triggered at release time, which might be when this note is still playing, if the note has some release envelope, but when the note is being deleted ## Syntax atstop Sinstrname, idelay, idur, ... atstop instrnum, idelay, idur, ... * Sinstrname / instrnum: the name or the instrument number to schedule * idelay: time offset to this note stop * idur: duration of the scheduled event (-1 = forever) */ sr = 44100 ksmps = 64 0dbfs = 1 nchnls = 2 opcode myvco , a , ii i amp , i freq xin a 0 vco2 , i amp , i freq a 0 += vco2 ( i amp , i freq + 2 ) a 0 += vco2 ( i amp , i freq / 2 ) xout a 0 endop ; brownian walk instr 1 i midi = p4 a 0 myvco 0.1 , mtof : i ( i midi ) outs a 0 , a 0 i delta = round (( rnd ( 4 ) - 1 ) * 2 ) / 2 i delta = i delta != 0 ? i delta : - 0.5 i midi2 = i midi + i delta i midi2 = i midi2 < 96 ? i midi2 : 48 i durnext = round ( rnd ( 0.25 ) * 8 ) / 8 a tstop 1 , 0 , i durnext , i midi2 endin ; ping-pong instr 2 i midi = p4 i midi = i midi < 96 ? i midi : 48 a 0 myvco 0.1 , mtof : i ( i midi ) a 0 *= linsegr ( 0 , 0.05 , 1 , 0.05 , 0 ) outs a 0 , a 0 a tstop 3 , 0 , p3 * 0.97 , i midi + 1 endin instr 3 i midi = p4 i midi = i midi < 88 ? i midi : 48 a 0 oscili 0.8 , mtof : i ( i midi ) a 0 *= linsegr ( 0 , 0.05 , 1 , 0.050 , 0 ) outs a 0 , a 0 a tstop 2 , 0 , p3 * 0.95 , i midi + 1 endin ; test calling a named instr at stop instr 10 a 0 oscili 0.1 , 440 outs a 0 , a 0 a tstop \"foo\" , 0.5 , 1 , 1000 endin instr foo i freq = p4 a 0 oscili 0.1 , i freq outs a 0 , a 0 endin ; test simple case with optional pargs instr first a tstop \"second\" , 1 , - 1 , 0.5 a tstop \"second\" , 0.5 a tstop 200 endin instr second printf \"second! p4 = %f \\n \" , 1 , p4 turnoff endin instr 200 printf \"200! \\n \" , 1 turnoff endin ; test atstop with k args instr _printCounter i counter = p4 prints \"counter: %d \\n \" , i counter turnoff endin instr kargs k counter init 0 k counter += 1 a tstop \"_printCounter\" , 0 , - 1 , k counter endin instr StopPerformance exitnow endin </ CsInstruments > < CsScore > ; i 1 0 0.25 36 ; i 2 0 0.25 48 ; i 10 0 1 ; i \"StopPerformance\" 10 1 ; i \"first\" 1 0.5 i \"kargs\" 0 1 f 0 5 </ CsScore > </ CsoundSynthesizer > See also defer schedule event release xtratim Credits Eduardo Moguillansky, 2019","title":"atstop"},{"location":"opcodes/atstop.html#atstop","text":"","title":"atstop"},{"location":"opcodes/atstop.html#abstract","text":"Schedule an instrument at the end of the current instrument","title":"Abstract"},{"location":"opcodes/atstop.html#description","text":"atstop can be used to schedule an instrument event as the last action of a given instrument, during the process of being deallocated. This can be used to notify when the note has actually stopped, or to schedule a chain of events, free any table or dict allocated, etc. The advantage over the release opcode is that atstop is guaranteed to be run after the note has stopped, so there is no danger in deallocating resources being used by this note, there are no conflicts with release envelopes, etc. If any k-variables are passed to the scheduled instr these will reflect the changes at the end of the instr. Release time vs deinit time The event is not scheduled at release time (see below \"Release time vs Deinit time\") but at the moment the note is freed. Release time is when the note is within its release phase , which will only happen if the note has an envelope with a release segment (like linsegr ), or if it has setup extra time with xtratim . The opcode release can be used to query if the current note is being released. The instrument keeps running in release phase as long as the release part of the envelope is finished or the extra time allocated via xtratim is through. Deinit time is the moment the note is actually being freed, so the instrument is not running anymore at this point.","title":"Description"},{"location":"opcodes/atstop.html#syntax","text":"a tstop i nstrnum [, i delay = 0 , i dur =- 1 , p4 , p5 , ... ] a tstop S instrname [, i delay = 0 , i dur =- 1 , p4 , p5 , ... ]","title":"Syntax"},{"location":"opcodes/atstop.html#arguments","text":"instrnum / Sintrname : the number or the name of the instr to be scheduled idelay : the time offset after the stop time of this note to start this instrument idur : the duration of the event p4 , p5 , ...: any other p-arguments, as used with similar opcodes like schedule , event , etc. They can be any i-, k- or S- variable. The scheduled instr will access them, as p-args.","title":"Arguments"},{"location":"opcodes/atstop.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/atstop.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* # This is the example file for the atstop opcode atstop schedules an instrument at the end of the note This might be useful to notify that a note stopped, or to schedule a chain of notes, etc. NB: the scheduled event is NOT triggered at release time, which might be when this note is still playing, if the note has some release envelope, but when the note is being deleted ## Syntax atstop Sinstrname, idelay, idur, ... atstop instrnum, idelay, idur, ... * Sinstrname / instrnum: the name or the instrument number to schedule * idelay: time offset to this note stop * idur: duration of the scheduled event (-1 = forever) */ sr = 44100 ksmps = 64 0dbfs = 1 nchnls = 2 opcode myvco , a , ii i amp , i freq xin a 0 vco2 , i amp , i freq a 0 += vco2 ( i amp , i freq + 2 ) a 0 += vco2 ( i amp , i freq / 2 ) xout a 0 endop ; brownian walk instr 1 i midi = p4 a 0 myvco 0.1 , mtof : i ( i midi ) outs a 0 , a 0 i delta = round (( rnd ( 4 ) - 1 ) * 2 ) / 2 i delta = i delta != 0 ? i delta : - 0.5 i midi2 = i midi + i delta i midi2 = i midi2 < 96 ? i midi2 : 48 i durnext = round ( rnd ( 0.25 ) * 8 ) / 8 a tstop 1 , 0 , i durnext , i midi2 endin ; ping-pong instr 2 i midi = p4 i midi = i midi < 96 ? i midi : 48 a 0 myvco 0.1 , mtof : i ( i midi ) a 0 *= linsegr ( 0 , 0.05 , 1 , 0.05 , 0 ) outs a 0 , a 0 a tstop 3 , 0 , p3 * 0.97 , i midi + 1 endin instr 3 i midi = p4 i midi = i midi < 88 ? i midi : 48 a 0 oscili 0.8 , mtof : i ( i midi ) a 0 *= linsegr ( 0 , 0.05 , 1 , 0.050 , 0 ) outs a 0 , a 0 a tstop 2 , 0 , p3 * 0.95 , i midi + 1 endin ; test calling a named instr at stop instr 10 a 0 oscili 0.1 , 440 outs a 0 , a 0 a tstop \"foo\" , 0.5 , 1 , 1000 endin instr foo i freq = p4 a 0 oscili 0.1 , i freq outs a 0 , a 0 endin ; test simple case with optional pargs instr first a tstop \"second\" , 1 , - 1 , 0.5 a tstop \"second\" , 0.5 a tstop 200 endin instr second printf \"second! p4 = %f \\n \" , 1 , p4 turnoff endin instr 200 printf \"200! \\n \" , 1 turnoff endin ; test atstop with k args instr _printCounter i counter = p4 prints \"counter: %d \\n \" , i counter turnoff endin instr kargs k counter init 0 k counter += 1 a tstop \"_printCounter\" , 0 , - 1 , k counter endin instr StopPerformance exitnow endin </ CsInstruments > < CsScore > ; i 1 0 0.25 36 ; i 2 0 0.25 48 ; i 10 0 1 ; i \"StopPerformance\" 10 1 ; i \"first\" 1 0.5 i \"kargs\" 0 1 f 0 5 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/atstop.html#see-also","text":"defer schedule event release xtratim","title":"See also"},{"location":"opcodes/atstop.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/bisect.html","text":"bisect Abstract Returns the fractional index of a value within a sorted array / tab Description Given an array x0, x1, x2, x3,... , bisect determines the fractional index of a value x, indicating where this value would be placed within the given array/table. For example, given an array [0, 10, 14, 20] , the value 12 would receive the index 1.5 since it is to be placed between elements 1 and 2, equidistant from both (the fractional part determines the relative distance to the neighbouring elements). The index is clamped to 0 and size-1 . Note bisect can be used together with interp1d to perform piecewise interpolation. Given an array of x values and an array of corrsponding y values, bisect determines the index within the x array and interp1d maps that index to the y domain via multiple interpolation methods Syntax k idx bisect k val , xarr [] i idx bisect i val , xarr [] a idx bisect a val , xarr [] k idx [] bisect k vals [], xarr [] i idx [] bisect i vals [], xarr [] k idx bisect k val , k tab , k step = 1 , k offset = 0 i idx bisect i val , i tab , i step = 1 , i offset = 0 a idx bisect a val , k tab , k step = 1 , k offset = 0 k idx [] bisect k val [], k tab , k step = 1 , k offset = 0 i idx [] bisect i val [], i tab , i step = 1 , i offset = 0 Arguments kval : the value to quiery within arr arr : the array (1D) holding the data. tab : the table holding the data step : in the case of a table, it is possible to bisect one particular column in the table if, for each row, multiple features are included in the same table offset : the offset determines the precise column to bisect Output out : the index of val inside the array/tab Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* Abstract ======== Determine the fractional index of a value within a sorted array / tab Description =========== Given an array x0, x1, x2, x3,..., determine the fractional index of a value x. For example, given an array [0, 10, 14, 20], the value 12 would receive the index 1.5 since it is to be placed between elements 1 and 2, equidistant from both. The fractional part determines the relative distance to the neighbouring elements. Syntax ====== kidx bisect kval, xarr[] iidx bisect ival, xarr[] aidx bisect aval, xarr[] kidx[] bisect kvals[], xarr[] iidx[] bisect ivals[], xarr[] kidx bisect kval, ktab, kstep=1, koffset=0 iidx bisect ival, itab, istep=1, ioffset=0 aidx bisect aval, ktab, kstep=1, koffset=0 kidx[] bisect kval[], ktab, kstep=1, koffset=0 iidx[] bisect ival[], itab, istep=1, ioffset=0 Args ==== kval: the value to quiery within arr arr: the array (1D) holding the data. tab: the table holding the data step: in the case of a table, it is possible to bisect one particular column in the table if, for each row, multiple features are included in the same table offset: the offset determines the precise column to bisect Output ====== out: the index of val inside the array/tab See Also ======== interp1d, bpf, linlin, getrowlin, linenv */ ksmps = 64 nchnls = 2 0dbfs = 1 instr example1 ; used together with bisect can create multiple piecewise interpolation ; configurations i times [] fillarray 0 , 4 , 5 , 10 i midi1 [] fillarray 64 , 64 , 63.5 , 64.5 i midi2 [] fillarray 64 , 63.4 , 63.4 , 63 i amps [] fillarray 0 , 0.8 , 0.8 , 0 k idx bisect timeinsts (), i times k amp i nterp1d k idx , i amps , \"cos\" a amp interp k amp a 1 oscili a amp , mtof ( i nterp1d ( k idx , i midi1 , \"cubic\" )) a 2 oscili a amp , mtof ( i nterp1d ( k idx , i midi2 )) println \"amp: %f \" , rms : k ( a amp ) outch 1 , a 1 , 2 , a 2 endin instr example2 ; a table can also be used with interp1d / bisect. A table can hold ; both x and y coordinates as pairs i time2midi1 f tfill 0 , 64 , 4 , 62 , 5 , 62 , 6 , 67 i time2midi2 f tfill 0 , 60 , 4 , 60 , 5 , 59 , 6 , 59 ftfree i time2midi1 , 1 ftfree i time2midi2 , 1 ; step=2, bisect the column 0. k t = timeinsts () k idx1 bisect k t , i time2midi1 , 2 k idx2 bisect k t , i time2midi2 , 2 ; -1: cosine interpolation, step size=2, offset=1 k midi1 i nterp1d k idx1 , i time2midi1 , \"cos\" , 2 , 1 k midi2 i nterp1d k idx2 , i time2midi2 , \"cos\" , 2 , 1 a 0 squinewave a ( mtof ( k midi1 )), a ( 0.1 ), a ( 0.1 ) a 1 squinewave a ( mtof ( k midi2 )), a ( 0.2 ), a ( 0.5 ) i gain = 0.1 i fade = 0.2 a env = linseg : a ( 0 , i fade , i gain , p3 - i fade * 2 - 0.1 , i gain , i fade , 0 ) outch 1 , a 0 * a env , 2 , a 1 * a env endin instr test1 i curve f tfill 1 , 60 , 3 , 65 , 4 , 60 k t timeinsts k idx bisect k t , i curve , 2 k midi i nterp1d k idx , k ( i curve ), \"linear\" , 2 , 1 println \"kt: %f , kidx: %f , kmidi: %f \" , k t , k idx , k midi endin </ CsInstruments > < CsScore > ; Uncomment to perform each example ;i \"example1\" 0 10 ;i \"example2\" 0 7 i \"test1\" 0 5 </ CsScore > </ CsoundSynthesizer > See Also interp1d bpf linlin getrowlin linenv","title":"bisect"},{"location":"opcodes/bisect.html#bisect","text":"","title":"bisect"},{"location":"opcodes/bisect.html#abstract","text":"Returns the fractional index of a value within a sorted array / tab","title":"Abstract"},{"location":"opcodes/bisect.html#description","text":"Given an array x0, x1, x2, x3,... , bisect determines the fractional index of a value x, indicating where this value would be placed within the given array/table. For example, given an array [0, 10, 14, 20] , the value 12 would receive the index 1.5 since it is to be placed between elements 1 and 2, equidistant from both (the fractional part determines the relative distance to the neighbouring elements). The index is clamped to 0 and size-1 . Note bisect can be used together with interp1d to perform piecewise interpolation. Given an array of x values and an array of corrsponding y values, bisect determines the index within the x array and interp1d maps that index to the y domain via multiple interpolation methods","title":"Description"},{"location":"opcodes/bisect.html#syntax","text":"k idx bisect k val , xarr [] i idx bisect i val , xarr [] a idx bisect a val , xarr [] k idx [] bisect k vals [], xarr [] i idx [] bisect i vals [], xarr [] k idx bisect k val , k tab , k step = 1 , k offset = 0 i idx bisect i val , i tab , i step = 1 , i offset = 0 a idx bisect a val , k tab , k step = 1 , k offset = 0 k idx [] bisect k val [], k tab , k step = 1 , k offset = 0 i idx [] bisect i val [], i tab , i step = 1 , i offset = 0","title":"Syntax"},{"location":"opcodes/bisect.html#arguments","text":"kval : the value to quiery within arr arr : the array (1D) holding the data. tab : the table holding the data step : in the case of a table, it is possible to bisect one particular column in the table if, for each row, multiple features are included in the same table offset : the offset determines the precise column to bisect","title":"Arguments"},{"location":"opcodes/bisect.html#output","text":"out : the index of val inside the array/tab","title":"Output"},{"location":"opcodes/bisect.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* Abstract ======== Determine the fractional index of a value within a sorted array / tab Description =========== Given an array x0, x1, x2, x3,..., determine the fractional index of a value x. For example, given an array [0, 10, 14, 20], the value 12 would receive the index 1.5 since it is to be placed between elements 1 and 2, equidistant from both. The fractional part determines the relative distance to the neighbouring elements. Syntax ====== kidx bisect kval, xarr[] iidx bisect ival, xarr[] aidx bisect aval, xarr[] kidx[] bisect kvals[], xarr[] iidx[] bisect ivals[], xarr[] kidx bisect kval, ktab, kstep=1, koffset=0 iidx bisect ival, itab, istep=1, ioffset=0 aidx bisect aval, ktab, kstep=1, koffset=0 kidx[] bisect kval[], ktab, kstep=1, koffset=0 iidx[] bisect ival[], itab, istep=1, ioffset=0 Args ==== kval: the value to quiery within arr arr: the array (1D) holding the data. tab: the table holding the data step: in the case of a table, it is possible to bisect one particular column in the table if, for each row, multiple features are included in the same table offset: the offset determines the precise column to bisect Output ====== out: the index of val inside the array/tab See Also ======== interp1d, bpf, linlin, getrowlin, linenv */ ksmps = 64 nchnls = 2 0dbfs = 1 instr example1 ; used together with bisect can create multiple piecewise interpolation ; configurations i times [] fillarray 0 , 4 , 5 , 10 i midi1 [] fillarray 64 , 64 , 63.5 , 64.5 i midi2 [] fillarray 64 , 63.4 , 63.4 , 63 i amps [] fillarray 0 , 0.8 , 0.8 , 0 k idx bisect timeinsts (), i times k amp i nterp1d k idx , i amps , \"cos\" a amp interp k amp a 1 oscili a amp , mtof ( i nterp1d ( k idx , i midi1 , \"cubic\" )) a 2 oscili a amp , mtof ( i nterp1d ( k idx , i midi2 )) println \"amp: %f \" , rms : k ( a amp ) outch 1 , a 1 , 2 , a 2 endin instr example2 ; a table can also be used with interp1d / bisect. A table can hold ; both x and y coordinates as pairs i time2midi1 f tfill 0 , 64 , 4 , 62 , 5 , 62 , 6 , 67 i time2midi2 f tfill 0 , 60 , 4 , 60 , 5 , 59 , 6 , 59 ftfree i time2midi1 , 1 ftfree i time2midi2 , 1 ; step=2, bisect the column 0. k t = timeinsts () k idx1 bisect k t , i time2midi1 , 2 k idx2 bisect k t , i time2midi2 , 2 ; -1: cosine interpolation, step size=2, offset=1 k midi1 i nterp1d k idx1 , i time2midi1 , \"cos\" , 2 , 1 k midi2 i nterp1d k idx2 , i time2midi2 , \"cos\" , 2 , 1 a 0 squinewave a ( mtof ( k midi1 )), a ( 0.1 ), a ( 0.1 ) a 1 squinewave a ( mtof ( k midi2 )), a ( 0.2 ), a ( 0.5 ) i gain = 0.1 i fade = 0.2 a env = linseg : a ( 0 , i fade , i gain , p3 - i fade * 2 - 0.1 , i gain , i fade , 0 ) outch 1 , a 0 * a env , 2 , a 1 * a env endin instr test1 i curve f tfill 1 , 60 , 3 , 65 , 4 , 60 k t timeinsts k idx bisect k t , i curve , 2 k midi i nterp1d k idx , k ( i curve ), \"linear\" , 2 , 1 println \"kt: %f , kidx: %f , kmidi: %f \" , k t , k idx , k midi endin </ CsInstruments > < CsScore > ; Uncomment to perform each example ;i \"example1\" 0 10 ;i \"example2\" 0 7 i \"test1\" 0 5 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/bisect.html#see-also","text":"interp1d bpf linlin getrowlin linenv","title":"See Also"},{"location":"opcodes/crackle.html","text":"crackle Abstract generates noise based on a chaotic equation Description crackle is a chaotic generator, the sound is generated with the following equation y[n] = p * y[n-1]- y[n-2] - 0.05 Port of supercollider's Crackle Syntax a out crackle k p Arguments kp : the p parameter in the equation, a value between 1.0 and 2.0 Output aout : audio output of the chaotic generator Execution Time Performance (audio) Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* # This is the example file for the crackle opcode crackle is a port of supercollider's crackle (taken from pd/else) crackle is a chaotic noise generator based on the equation: y[n] = p * y[n-1] - y[n-2] - 0.05 ## Syntax aout crackle kp=0.5 * kp: value for p in the equation (default = 0.5) * aout: noise signal */ sr = 44100 ksmps = 64 0dbfs = 1 nchnls = 2 instr 1 k P [] fillarray 1.0 , 1.2 , 1.3 , 1.35 , 1.4 , 1.5 , 1.8 , 1.9 , 1.97 , 2.0 k idx = int ( line ( 0 , p3 , lenarray ( k P ))) k p = k P [ k idx ] printk2 k p a out crackle k p a out *= 0.5 outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 15 </ CsScore > </ CsoundSynthesizer > See also standardchaos chuap dust2 Credits Eduardo Moguillansky, 2019","title":"crackle"},{"location":"opcodes/crackle.html#crackle","text":"","title":"crackle"},{"location":"opcodes/crackle.html#abstract","text":"generates noise based on a chaotic equation","title":"Abstract"},{"location":"opcodes/crackle.html#description","text":"crackle is a chaotic generator, the sound is generated with the following equation y[n] = p * y[n-1]- y[n-2] - 0.05 Port of supercollider's Crackle","title":"Description"},{"location":"opcodes/crackle.html#syntax","text":"a out crackle k p","title":"Syntax"},{"location":"opcodes/crackle.html#arguments","text":"kp : the p parameter in the equation, a value between 1.0 and 2.0","title":"Arguments"},{"location":"opcodes/crackle.html#output","text":"aout : audio output of the chaotic generator","title":"Output"},{"location":"opcodes/crackle.html#execution-time","text":"Performance (audio)","title":"Execution Time"},{"location":"opcodes/crackle.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* # This is the example file for the crackle opcode crackle is a port of supercollider's crackle (taken from pd/else) crackle is a chaotic noise generator based on the equation: y[n] = p * y[n-1] - y[n-2] - 0.05 ## Syntax aout crackle kp=0.5 * kp: value for p in the equation (default = 0.5) * aout: noise signal */ sr = 44100 ksmps = 64 0dbfs = 1 nchnls = 2 instr 1 k P [] fillarray 1.0 , 1.2 , 1.3 , 1.35 , 1.4 , 1.5 , 1.8 , 1.9 , 1.97 , 2.0 k idx = int ( line ( 0 , p3 , lenarray ( k P ))) k p = k P [ k idx ] printk2 k p a out crackle k p a out *= 0.5 outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 15 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/crackle.html#see-also","text":"standardchaos chuap dust2","title":"See also"},{"location":"opcodes/crackle.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/deref.html","text":"deref Abstract Dereference a previously created reference to a variable Description ref and deref implement a mechanism to pass a reference to any object, allowing to share a variable across instruments, with opcodes, etc. A ref is reference counted and deallocates itself when it falls out of scope without being referenced by any object. It makes it possible to pass arrays by reference to user defined opcodes, allowing to modify an array inplace, skip copying memory, etc. Syntax xArray deref iref, iextrarefs=0 Arguments iref : a reference index as created via ref iextrarefs : extra references used, matching any extra reference allocated via ref (see ref for more information) Output xArray / xvar : are created as a view of the object originally passed to ref Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > ;; Example file for ref - deref sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 gi A [] fillarray 0 , 1000 , 2000 , 3000 ; Example 1: take a ref from an array, deref it to create a second view of it instr 1 ; a source array i X [] fillarray 0 , 10 , 20 , 30 , 40 ; create a ref of iXs, return the index i ref ref i X ; now iYs points to iXs i Y [] deref i ref printarray i Y , \"\" , \"instrument 1, iY\" i Z [] fillarray 0 , 1 , 3 , 5 , 7 ; create a ref, pass it to instr. 2 schedule 2 , 0 , 1 , ref ( i Z ) ; create another ref of iZ. In this case the event is scheduled ; in the future, so the source will not exist anymore when instr. 2 ; is scheduled. This should fail. schedule 2 , 1 , 1 , ref ( i Z ) turnoff endin instr 2 i ref = p4 if refvalid ( i ref ) == 1 then i Zs [] deref i ref printarray i Zs , \"\" , \"p1=2, iZs\" else prints \" \\n The reference has become invalid \\n \" endif turnoff endin ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; Example 2: extra references to keep array alive instr 3 ; create a source array k Xs [] fillarray 1 , 1 , 2 , 3 , 5 , 8 , 13 ; In order to bridge the time gap between the end of life of the source ; of a ref and the scheduled event where a deref is taken, it is possible ; to create a forward reference, a \"promise\" that one deref has been scheduled ; in the future. ; short lived event, ends before this event schedule 4 , 0 , 0.1 , ref ( k Xs ), 0 ; starts before we end, but survives us schedule 4 , p3 - 0.1 , 0.2 , ref ( k Xs ), 0 ; starts after we end, we need an extra reference schedule 4 , p3 + 1 , 0.1 , ref ( k Xs , 1 ), 1 defer \"prints\" , \" --- instr. 3 finished --- \\n \" endin instr 4 prints \"instr. 4 \\n \" k View [] deref p4 , p5 printarray k View defer \"prints\" , \" --- instr. 4 finished --- \\n \" ; At deinition time the memory of the `iView` array is marked as deallocated. ; The handle (a global structure created by the `ref` opcode) which owns the memory, ; is signaled that no other clients of this data are alive. It deallocates the ; original memory and frees itself endin ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; test: multiple derefs instr 5 i Xs [] fillarray 0 , 1 , 4 , 9 i ref ref i Xs i Ys [] deref i ref i Zs [] deref i ref printarray i Ys printarray i Zs i Xs [ 0 ] = 100 printarray i Zs turnoff endin ; test performance of pass-by-value vs pass-by-reference opcode arrayadd , i[] , i[]i ; pass by value in and out i In [], i x xin i Out [] = i In + i x xout i Out endop opcode arrayaddref , i[] , ii ; pass by ref in, by value out i ref , i x xin i In [] deref i ref i Out [] = i In + i x xout i Out endop opcode arrayadd_inplace , 0 , ii ; in place i ref , i x xin i In [] deref i ref i In += i x endop opcode arrayadd_byref_inout , 0 , iii ; pass by ref in and out i refin , i refout , i x xin i In [] deref i refin i Out [] deref i refout if lenarray ( i Out ) >= lenarray ( i In ) then i Out = i In + i x endif endop instr testUdoPerformance1 ; Here we test the performance gain of passing arrays by reference. ; Passing the input array by reference seems to produce a speedup of ~25%, i num = 10000 i Xs [] genarray 0 , i num i i = 0 i t0 rtclock while i i < 20 do i Ys [] arrayadd i Xs , 2.0 i i += 1 od i t1 rtclock prints \"Dur UDO pass by value = %.8f \\n \" , i t1 - i t0 i ref = ref ( i Xs ) i t0 rtclock i Y0 [] arrayaddref i ref , 0.1 i Y0 arrayaddref i ref , 0.2 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i t1 rtclock prints \"Dur UDO pass by ref input = %.8f \\n \" , i t1 - i t0 i Zs [] genarray 0 , i num i Out [] init lenarray ( i Zs ) i t0 rtclock i refZ = ref ( i Zs ) i refOut = ref ( i Out ) arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 i t1 rtclock prints \"Dur UDO pass by ref in and out= %.8f \\n \" , i t1 - i t0 ; printarray iOut endin instr 7 i In [] genarray 0 , 1000 i Out [] init lenarray ( i In ) arrayadd_byref_inout ref ( i In ), ref ( i Out ), 0.5 turnoff endin instr 8 ; test k arrays ; 1. A way to convert a i-array to a k-array by taking a reference i Xs [] genarray 0 , 99 k Xs [] deref ref ( i Xs ) k Xs [ 0 ] = timeinsts () printarray k Xs , metro ( 8 ) endin instr 9 ; we need genarray_i because otherwise kXs is not initialized at i-time k Xs [] genarray 0 , 9 i Xs [] deref ref ( k Xs ) i Xs += 10 printarray i Xs printarray k Xs turnoff endin ; schedule 1, 0, 1 ; schedule 3, 0, 1 ; schedule 5, 0, 0.1 schedule \"testUdoPerformance1\" , 0 , 0.1 ; schedule 8, 0, 4 </ CsInstruments > < CsScore > e 10 </ CsScore > </ CsoundSynthesizer > See also ref defer schedule event release Credits Eduardo Moguillansky, 2019","title":"deref"},{"location":"opcodes/deref.html#deref","text":"","title":"deref"},{"location":"opcodes/deref.html#abstract","text":"Dereference a previously created reference to a variable","title":"Abstract"},{"location":"opcodes/deref.html#description","text":"ref and deref implement a mechanism to pass a reference to any object, allowing to share a variable across instruments, with opcodes, etc. A ref is reference counted and deallocates itself when it falls out of scope without being referenced by any object. It makes it possible to pass arrays by reference to user defined opcodes, allowing to modify an array inplace, skip copying memory, etc.","title":"Description"},{"location":"opcodes/deref.html#syntax","text":"xArray deref iref, iextrarefs=0","title":"Syntax"},{"location":"opcodes/deref.html#arguments","text":"iref : a reference index as created via ref iextrarefs : extra references used, matching any extra reference allocated via ref (see ref for more information)","title":"Arguments"},{"location":"opcodes/deref.html#output","text":"xArray / xvar : are created as a view of the object originally passed to ref","title":"Output"},{"location":"opcodes/deref.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/deref.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > ;; Example file for ref - deref sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 gi A [] fillarray 0 , 1000 , 2000 , 3000 ; Example 1: take a ref from an array, deref it to create a second view of it instr 1 ; a source array i X [] fillarray 0 , 10 , 20 , 30 , 40 ; create a ref of iXs, return the index i ref ref i X ; now iYs points to iXs i Y [] deref i ref printarray i Y , \"\" , \"instrument 1, iY\" i Z [] fillarray 0 , 1 , 3 , 5 , 7 ; create a ref, pass it to instr. 2 schedule 2 , 0 , 1 , ref ( i Z ) ; create another ref of iZ. In this case the event is scheduled ; in the future, so the source will not exist anymore when instr. 2 ; is scheduled. This should fail. schedule 2 , 1 , 1 , ref ( i Z ) turnoff endin instr 2 i ref = p4 if refvalid ( i ref ) == 1 then i Zs [] deref i ref printarray i Zs , \"\" , \"p1=2, iZs\" else prints \" \\n The reference has become invalid \\n \" endif turnoff endin ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; Example 2: extra references to keep array alive instr 3 ; create a source array k Xs [] fillarray 1 , 1 , 2 , 3 , 5 , 8 , 13 ; In order to bridge the time gap between the end of life of the source ; of a ref and the scheduled event where a deref is taken, it is possible ; to create a forward reference, a \"promise\" that one deref has been scheduled ; in the future. ; short lived event, ends before this event schedule 4 , 0 , 0.1 , ref ( k Xs ), 0 ; starts before we end, but survives us schedule 4 , p3 - 0.1 , 0.2 , ref ( k Xs ), 0 ; starts after we end, we need an extra reference schedule 4 , p3 + 1 , 0.1 , ref ( k Xs , 1 ), 1 defer \"prints\" , \" --- instr. 3 finished --- \\n \" endin instr 4 prints \"instr. 4 \\n \" k View [] deref p4 , p5 printarray k View defer \"prints\" , \" --- instr. 4 finished --- \\n \" ; At deinition time the memory of the `iView` array is marked as deallocated. ; The handle (a global structure created by the `ref` opcode) which owns the memory, ; is signaled that no other clients of this data are alive. It deallocates the ; original memory and frees itself endin ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; test: multiple derefs instr 5 i Xs [] fillarray 0 , 1 , 4 , 9 i ref ref i Xs i Ys [] deref i ref i Zs [] deref i ref printarray i Ys printarray i Zs i Xs [ 0 ] = 100 printarray i Zs turnoff endin ; test performance of pass-by-value vs pass-by-reference opcode arrayadd , i[] , i[]i ; pass by value in and out i In [], i x xin i Out [] = i In + i x xout i Out endop opcode arrayaddref , i[] , ii ; pass by ref in, by value out i ref , i x xin i In [] deref i ref i Out [] = i In + i x xout i Out endop opcode arrayadd_inplace , 0 , ii ; in place i ref , i x xin i In [] deref i ref i In += i x endop opcode arrayadd_byref_inout , 0 , iii ; pass by ref in and out i refin , i refout , i x xin i In [] deref i refin i Out [] deref i refout if lenarray ( i Out ) >= lenarray ( i In ) then i Out = i In + i x endif endop instr testUdoPerformance1 ; Here we test the performance gain of passing arrays by reference. ; Passing the input array by reference seems to produce a speedup of ~25%, i num = 10000 i Xs [] genarray 0 , i num i i = 0 i t0 rtclock while i i < 20 do i Ys [] arrayadd i Xs , 2.0 i i += 1 od i t1 rtclock prints \"Dur UDO pass by value = %.8f \\n \" , i t1 - i t0 i ref = ref ( i Xs ) i t0 rtclock i Y0 [] arrayaddref i ref , 0.1 i Y0 arrayaddref i ref , 0.2 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i t1 rtclock prints \"Dur UDO pass by ref input = %.8f \\n \" , i t1 - i t0 i Zs [] genarray 0 , i num i Out [] init lenarray ( i Zs ) i t0 rtclock i refZ = ref ( i Zs ) i refOut = ref ( i Out ) arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 i t1 rtclock prints \"Dur UDO pass by ref in and out= %.8f \\n \" , i t1 - i t0 ; printarray iOut endin instr 7 i In [] genarray 0 , 1000 i Out [] init lenarray ( i In ) arrayadd_byref_inout ref ( i In ), ref ( i Out ), 0.5 turnoff endin instr 8 ; test k arrays ; 1. A way to convert a i-array to a k-array by taking a reference i Xs [] genarray 0 , 99 k Xs [] deref ref ( i Xs ) k Xs [ 0 ] = timeinsts () printarray k Xs , metro ( 8 ) endin instr 9 ; we need genarray_i because otherwise kXs is not initialized at i-time k Xs [] genarray 0 , 9 i Xs [] deref ref ( k Xs ) i Xs += 10 printarray i Xs printarray k Xs turnoff endin ; schedule 1, 0, 1 ; schedule 3, 0, 1 ; schedule 5, 0, 0.1 schedule \"testUdoPerformance1\" , 0 , 0.1 ; schedule 8, 0, 4 </ CsInstruments > < CsScore > e 10 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/deref.html#see-also","text":"ref defer schedule event release","title":"See also"},{"location":"opcodes/deref.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/detectsilence.html","text":"detectsilence Abstract Detect when input falls below an amplitude threshold Description When the absolute value of the input signal remains below the threshold for a given window of time, output 1. Otherwise, output 0. This can be used to detect the end of a sample or the end of a complex envelope detectsilence is a port of SuperCollider's DetectSilence UGen ( https://doc.sccode.org/Classes/DetectSilence.html ) Syntax k out detectsilence a sig , k thresh = 0.0001 , k time = 0.1 Arguments asig : the audio signal to analyze kthresh : the amplitude threshold ktime : the time period the signal should stay below the threshold Output kout : 1 if the signal has been below the threshold for the given time, 0 otherwise Execution Time Performance Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 a sig oscili 0.5 , 1000 a env linseg 0 , 0.1 , 1 , 1.9 , 1 , 1 , 0 ; total 0.1+1.9+1=3 a sig *= a env k finished = detectsilence ( a sig , db ( - 90 ), 0.1 ) k ms = timeinsts () * 1000 if metro ( 30 ) == 1 then printsk \" \\r Elapsed time: %.2f ms, env: %.5f \" , k ms , a env [ 0 ] endif if k finished == 1 then turnoff endif defer \"prints\" , \" \\n Instrument exited after %.2f ms \\n \" , k ms endin </ CsInstruments > < CsScore > i 1 1 8 ; f0 3600 </ CsScore > </ CsoundSynthesizer > See also follow2 rms Credits Eduardo Moguillansky, 2021","title":"detectsilence"},{"location":"opcodes/detectsilence.html#detectsilence","text":"","title":"detectsilence"},{"location":"opcodes/detectsilence.html#abstract","text":"Detect when input falls below an amplitude threshold","title":"Abstract"},{"location":"opcodes/detectsilence.html#description","text":"When the absolute value of the input signal remains below the threshold for a given window of time, output 1. Otherwise, output 0. This can be used to detect the end of a sample or the end of a complex envelope detectsilence is a port of SuperCollider's DetectSilence UGen ( https://doc.sccode.org/Classes/DetectSilence.html )","title":"Description"},{"location":"opcodes/detectsilence.html#syntax","text":"k out detectsilence a sig , k thresh = 0.0001 , k time = 0.1","title":"Syntax"},{"location":"opcodes/detectsilence.html#arguments","text":"asig : the audio signal to analyze kthresh : the amplitude threshold ktime : the time period the signal should stay below the threshold","title":"Arguments"},{"location":"opcodes/detectsilence.html#output","text":"kout : 1 if the signal has been below the threshold for the given time, 0 otherwise","title":"Output"},{"location":"opcodes/detectsilence.html#execution-time","text":"Performance","title":"Execution Time"},{"location":"opcodes/detectsilence.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 a sig oscili 0.5 , 1000 a env linseg 0 , 0.1 , 1 , 1.9 , 1 , 1 , 0 ; total 0.1+1.9+1=3 a sig *= a env k finished = detectsilence ( a sig , db ( - 90 ), 0.1 ) k ms = timeinsts () * 1000 if metro ( 30 ) == 1 then printsk \" \\r Elapsed time: %.2f ms, env: %.5f \" , k ms , a env [ 0 ] endif if k finished == 1 then turnoff endif defer \"prints\" , \" \\n Instrument exited after %.2f ms \\n \" , k ms endin </ CsInstruments > < CsScore > i 1 1 8 ; f0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/detectsilence.html#see-also","text":"follow2 rms","title":"See also"},{"location":"opcodes/detectsilence.html#credits","text":"Eduardo Moguillansky, 2021","title":"Credits"},{"location":"opcodes/diode_ringmod.html","text":"diode_ringmod Abstract A ring modulator with optional non-linearities Description diode_ringmod is a ring modulator with optional non-linearities. It implements a built-in sinusoidal carrier signal. The carrier is passed through a diode simulation prior to being multiplied with the input. This signal passes through a feedback stage. Sinewave : Diode Rect (abs(x)*2-0.2) : _ * Input : Feedback knonlinearities controls the amount of jitter in the carrier's freq and feedback amount. diode_ringmod is a port of Loser's ringmodulator jsfx plugin distributed with REAPER Syntax a out diode_ringmod a in , k freq , k diode = 0 , k feedback = 0 , k nonlinear = 0 , k oversample = 0 Arguments ain : the input signal kfreq : the carrier's frequency (a sine wave) kdiode : if 1, the carrier is passed through a diode rectification stage kfeedback : the amount of feedback (between 0 and 1, 0=no feedback) knonlinear : the amount of non linearities (between 0 and 1, 0=no non linearities) koversample : if 1, oversampling x 2 is performed Output aout : audio output of the ring modulator Execution Time Performance (audio) Examples < CsoundSynthesizer > < CsOptions > - odac - d - m0 -+ rtmidi = virtual - M0 </ CsOptions > < CsInstruments > /* This is the example file for diode_ringmod NB: diode_ringmod is a port of the jsfx plugin Loser/ringmodulator, which implements diode rectification and non linear behavior in the feedback path. aout diode_ringmode a1, kmodfreq, kdiode=1, kfeedback=0, knonlin=0.2, koversample=0 kmodfreq: frequency of the mod. signal kdiode: if 1, a diode rectification stage is applied to the mod. signal kfeedback: range is 0 to 1. knonlin: range 0 to 1, implements non-linearities in feedback and mod. freq (for the first case only, which used the builtin oscillator) koversample: if 1, 2x oversampling is used. */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ga Outs [] init 2 FLpanel \"dioderingmod\" , 443 , 360 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i __w , i __h , i __line = 300 , 30 , 60 i y , i __marginx = 30 , 30 i _v1 FLvalue \"\" , 50 , 30 , 333 , i y gk ModFrequency , i _s1 FLslider \"Mod Frequency (Hz)\" , 20.0 , 3000.0 , 0 , 3 , \\ i _v1 , i __w , i __h , i __marginx , i y i y += i __line i _v2 FLvalue \"\" , 50 , 30 , 333 , i y gk Diode , i _s2 FLslider \"Diode\" , 0.0 , 1.0 , 0 , 3 , \\ i _v2 , i __w , i __h , i __marginx , i y i y += i __line i _v3 FLvalue \"\" , 50 , 30 , 333 , i y gk Feedback , i _s3 FLslider \"Feedback\" , 0.0 , 1.0 , 0 , 3 , \\ i _v3 , i __w , i __h , i __marginx , i y i y += i __line i _v4 FLvalue \"\" , 50 , 30 , 333 , i y gk Nonlinearities , i _s4 FLslider \"Non-Linearities\" , 0.0 , 1.0 , 0 , 3 , \\ i _v4 , i __w , i __h , i __marginx , i y i y += i __line i _v5 FLvalue \"\" , 50 , 30 , 333 , i y gk Oversample , i _s5 FLslider \"Oversample (x2)\" , 0.0 , 1.0 , 0 , 3 , \\ i _v5 , i __w , i __h , i __marginx , i y FLpanelEnd FLrun FLsetVal_i 440.0 , i _s1 ; Mod Frequency (Hz) FLsetVal_i 0.0 , i _s2 ; Diode FLsetVal_i 0.0 , i _s3 ; Feedback FLsetVal_i 0.1 , i _s4 ; Non-Linearities FLsetVal_i 0.0 , i _s5 ; Oversample (x2); --- end ui massign 1 , 1 instr 1 i midinote notnum i freq mtof i midinote i vel1 ampmidi 127 i db bpf i vel1 , 0 , - 120 , 64 , - 20 , 90 , - 12 , 127 , 0 i amp = ampdb ( i db ) * 0.2 a sig vco2 i amp , i freq ; asig oscili iamp, ifreq a env adsr 0.01 , 0.1 , 0.8 , 0.2 a sig *= a env ga Outs [ 0 ] = ga Outs [ 0 ] + a sig endin instr 100 a 1 = ga Outs [ 0 ] a 2 diode_ringmod a 1 , gk ModFrequency , gk Diode , gk Feedback , gk Nonlinearities , gk Oversample outs a 2 , a 2 ga Outs [ 0 ] = 0 endin </ CsInstruments > < CsScore > i 100 0 3600 </ CsScore > </ CsoundSynthesizer > < bsbPanel > < label > Widgets </ label > < objectName /> < x > 100 </ x > < y > 100 </ y > < w idth > 320 </ w idth > < height > 240 </ height > < visible > true </ visible > < uuid /> < bgcolor mode = \"nobackground\" > < r > 255 </ r > < g > 255 </ g > < b > 255 </ b > </ bgcolor > </ bsbPanel > < bsbPresets > </ bsbPresets > See also hilbert Reference https://en.wikipedia.org/wiki/Ring_modulation Credits Eduardo Moguillansky, 2019","title":"diode_ringmod"},{"location":"opcodes/diode_ringmod.html#diode_ringmod","text":"","title":"diode_ringmod"},{"location":"opcodes/diode_ringmod.html#abstract","text":"A ring modulator with optional non-linearities","title":"Abstract"},{"location":"opcodes/diode_ringmod.html#description","text":"diode_ringmod is a ring modulator with optional non-linearities. It implements a built-in sinusoidal carrier signal. The carrier is passed through a diode simulation prior to being multiplied with the input. This signal passes through a feedback stage. Sinewave : Diode Rect (abs(x)*2-0.2) : _ * Input : Feedback knonlinearities controls the amount of jitter in the carrier's freq and feedback amount. diode_ringmod is a port of Loser's ringmodulator jsfx plugin distributed with REAPER","title":"Description"},{"location":"opcodes/diode_ringmod.html#syntax","text":"a out diode_ringmod a in , k freq , k diode = 0 , k feedback = 0 , k nonlinear = 0 , k oversample = 0","title":"Syntax"},{"location":"opcodes/diode_ringmod.html#arguments","text":"ain : the input signal kfreq : the carrier's frequency (a sine wave) kdiode : if 1, the carrier is passed through a diode rectification stage kfeedback : the amount of feedback (between 0 and 1, 0=no feedback) knonlinear : the amount of non linearities (between 0 and 1, 0=no non linearities) koversample : if 1, oversampling x 2 is performed","title":"Arguments"},{"location":"opcodes/diode_ringmod.html#output","text":"aout : audio output of the ring modulator","title":"Output"},{"location":"opcodes/diode_ringmod.html#execution-time","text":"Performance (audio)","title":"Execution Time"},{"location":"opcodes/diode_ringmod.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac - d - m0 -+ rtmidi = virtual - M0 </ CsOptions > < CsInstruments > /* This is the example file for diode_ringmod NB: diode_ringmod is a port of the jsfx plugin Loser/ringmodulator, which implements diode rectification and non linear behavior in the feedback path. aout diode_ringmode a1, kmodfreq, kdiode=1, kfeedback=0, knonlin=0.2, koversample=0 kmodfreq: frequency of the mod. signal kdiode: if 1, a diode rectification stage is applied to the mod. signal kfeedback: range is 0 to 1. knonlin: range 0 to 1, implements non-linearities in feedback and mod. freq (for the first case only, which used the builtin oscillator) koversample: if 1, 2x oversampling is used. */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ga Outs [] init 2 FLpanel \"dioderingmod\" , 443 , 360 , 50 , 50 FLcolor 150 , 100 , 150 , 200 , 100 , 250 i __w , i __h , i __line = 300 , 30 , 60 i y , i __marginx = 30 , 30 i _v1 FLvalue \"\" , 50 , 30 , 333 , i y gk ModFrequency , i _s1 FLslider \"Mod Frequency (Hz)\" , 20.0 , 3000.0 , 0 , 3 , \\ i _v1 , i __w , i __h , i __marginx , i y i y += i __line i _v2 FLvalue \"\" , 50 , 30 , 333 , i y gk Diode , i _s2 FLslider \"Diode\" , 0.0 , 1.0 , 0 , 3 , \\ i _v2 , i __w , i __h , i __marginx , i y i y += i __line i _v3 FLvalue \"\" , 50 , 30 , 333 , i y gk Feedback , i _s3 FLslider \"Feedback\" , 0.0 , 1.0 , 0 , 3 , \\ i _v3 , i __w , i __h , i __marginx , i y i y += i __line i _v4 FLvalue \"\" , 50 , 30 , 333 , i y gk Nonlinearities , i _s4 FLslider \"Non-Linearities\" , 0.0 , 1.0 , 0 , 3 , \\ i _v4 , i __w , i __h , i __marginx , i y i y += i __line i _v5 FLvalue \"\" , 50 , 30 , 333 , i y gk Oversample , i _s5 FLslider \"Oversample (x2)\" , 0.0 , 1.0 , 0 , 3 , \\ i _v5 , i __w , i __h , i __marginx , i y FLpanelEnd FLrun FLsetVal_i 440.0 , i _s1 ; Mod Frequency (Hz) FLsetVal_i 0.0 , i _s2 ; Diode FLsetVal_i 0.0 , i _s3 ; Feedback FLsetVal_i 0.1 , i _s4 ; Non-Linearities FLsetVal_i 0.0 , i _s5 ; Oversample (x2); --- end ui massign 1 , 1 instr 1 i midinote notnum i freq mtof i midinote i vel1 ampmidi 127 i db bpf i vel1 , 0 , - 120 , 64 , - 20 , 90 , - 12 , 127 , 0 i amp = ampdb ( i db ) * 0.2 a sig vco2 i amp , i freq ; asig oscili iamp, ifreq a env adsr 0.01 , 0.1 , 0.8 , 0.2 a sig *= a env ga Outs [ 0 ] = ga Outs [ 0 ] + a sig endin instr 100 a 1 = ga Outs [ 0 ] a 2 diode_ringmod a 1 , gk ModFrequency , gk Diode , gk Feedback , gk Nonlinearities , gk Oversample outs a 2 , a 2 ga Outs [ 0 ] = 0 endin </ CsInstruments > < CsScore > i 100 0 3600 </ CsScore > </ CsoundSynthesizer > < bsbPanel > < label > Widgets </ label > < objectName /> < x > 100 </ x > < y > 100 </ y > < w idth > 320 </ w idth > < height > 240 </ height > < visible > true </ visible > < uuid /> < bgcolor mode = \"nobackground\" > < r > 255 </ r > < g > 255 </ g > < b > 255 </ b > </ bgcolor > </ bsbPanel > < bsbPresets > </ bsbPresets >","title":"Examples"},{"location":"opcodes/diode_ringmod.html#see-also","text":"hilbert","title":"See also"},{"location":"opcodes/diode_ringmod.html#reference","text":"https://en.wikipedia.org/wiki/Ring_modulation","title":"Reference"},{"location":"opcodes/diode_ringmod.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/extendarray.html","text":"extendarray Abstract Extend one array with the contents of a second array, in place Description extendarray concatenates two arrays, placing the results in the first array. It works either at init or performance time, depending on the arrays passed. Syntax extendarray i Array1 [], i Array2 extendarray k Array1 [], k Array2 extendarray k Array1 [], i Array2 extendarray S Array1 [], S Array2 Arguments xArray1 : the first array and the array where the result is placed xArray2 : the second array Output Execution Time Init (if all arguments are of i type) Performance (for k or S types) Examples i Arr1 [] fillarray 0 , 1 , 2 i Arr2 [] fillarray 3 , 4 , 5 extendarray i Arr1 , i Arr2 ; iArr1 is now [0, 1, 2, 3, 4, 5] See also setslice setrow slicearray ) ftset ftslice Credits Eduardo Moguillansky, 2020","title":"extendarray"},{"location":"opcodes/extendarray.html#extendarray","text":"","title":"extendarray"},{"location":"opcodes/extendarray.html#abstract","text":"Extend one array with the contents of a second array, in place","title":"Abstract"},{"location":"opcodes/extendarray.html#description","text":"extendarray concatenates two arrays, placing the results in the first array. It works either at init or performance time, depending on the arrays passed.","title":"Description"},{"location":"opcodes/extendarray.html#syntax","text":"extendarray i Array1 [], i Array2 extendarray k Array1 [], k Array2 extendarray k Array1 [], i Array2 extendarray S Array1 [], S Array2","title":"Syntax"},{"location":"opcodes/extendarray.html#arguments","text":"xArray1 : the first array and the array where the result is placed xArray2 : the second array","title":"Arguments"},{"location":"opcodes/extendarray.html#output","text":"","title":"Output"},{"location":"opcodes/extendarray.html#execution-time","text":"Init (if all arguments are of i type) Performance (for k or S types)","title":"Execution Time"},{"location":"opcodes/extendarray.html#examples","text":"i Arr1 [] fillarray 0 , 1 , 2 i Arr2 [] fillarray 3 , 4 , 5 extendarray i Arr1 , i Arr2 ; iArr1 is now [0, 1, 2, 3, 4, 5]","title":"Examples"},{"location":"opcodes/extendarray.html#see-also","text":"setslice setrow slicearray ) ftset ftslice","title":"See also"},{"location":"opcodes/extendarray.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/fileexists.html","text":"file_exists Abstract Returns 1 if a file exists and can be read Description file_exists checks if a given file path exists and returns 1 if it does, 0 otherwise. It doesn't check any search path of csound and does not expand any variables (like \"~\" in unix). Syntax i exists f ile_exists S path Arguments Spath : the path to check Output iexists : 1 if the file exists, 0 otherwise Execution Time Init Examples < CsoundSynthesizer > < CsOptions > </ CsOptions > < CsInstruments > /* Example file for file_exists file_exists returns 1 if a given path refers to an existing file */ ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 i exists f ile_exists \"file_exists.csd\" print i exists turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer > See also filevalid system Credits Eduardo Moguillansky, 2019","title":"file_exists"},{"location":"opcodes/fileexists.html#file_exists","text":"","title":"file_exists"},{"location":"opcodes/fileexists.html#abstract","text":"Returns 1 if a file exists and can be read","title":"Abstract"},{"location":"opcodes/fileexists.html#description","text":"file_exists checks if a given file path exists and returns 1 if it does, 0 otherwise. It doesn't check any search path of csound and does not expand any variables (like \"~\" in unix).","title":"Description"},{"location":"opcodes/fileexists.html#syntax","text":"i exists f ile_exists S path","title":"Syntax"},{"location":"opcodes/fileexists.html#arguments","text":"Spath : the path to check","title":"Arguments"},{"location":"opcodes/fileexists.html#output","text":"iexists : 1 if the file exists, 0 otherwise","title":"Output"},{"location":"opcodes/fileexists.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/fileexists.html#examples","text":"< CsoundSynthesizer > < CsOptions > </ CsOptions > < CsInstruments > /* Example file for file_exists file_exists returns 1 if a given path refers to an existing file */ ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 i exists f ile_exists \"file_exists.csd\" print i exists turnoff endin </ CsInstruments > < CsScore > i 1 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/fileexists.html#see-also","text":"filevalid system","title":"See also"},{"location":"opcodes/fileexists.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/findFileInPath.html","text":"findFileInPath Abstract Find a file inside the search paths of the csound environment Description Search for an existing file as csound would search when ,for example, loading a sample. Returns the absolute path Syntax Spath fileFind Sfile Arguments Sfile : a relative path to an existing file Output Sout : the absolute path, or \"\" if not found Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Sabspath findFileInPath Sfile Searched for Sfile, first in the current directory, then in the directories specified in SSDIR. Returns the absolute path or an empty string to signal that the file was not found. */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 ; find the directory of this script S path f indFileInPath \"findFileInPath.csd\" if strlen ( S path ) == 0 then i niterror \"Could not find file\" endif S dir , S base pathSplit S path prints \"Spath: %s \\n Folder: %s \\n \" , S path , S dir S value getEnvVar \"SSDIR\" prints \"SSDIR: %s \\n \" , S value S scriptdir scriptDir prints \"Directory of current script: %s \\n \" , S scriptdir turnoff endin </ CsInstruments > < CsScore > i 1 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer > See also scriptDir Credits Eduardo Moguillansky, 2020","title":"findFileInPath"},{"location":"opcodes/findFileInPath.html#findfileinpath","text":"","title":"findFileInPath"},{"location":"opcodes/findFileInPath.html#abstract","text":"Find a file inside the search paths of the csound environment","title":"Abstract"},{"location":"opcodes/findFileInPath.html#description","text":"Search for an existing file as csound would search when ,for example, loading a sample. Returns the absolute path","title":"Description"},{"location":"opcodes/findFileInPath.html#syntax","text":"Spath fileFind Sfile","title":"Syntax"},{"location":"opcodes/findFileInPath.html#arguments","text":"Sfile : a relative path to an existing file","title":"Arguments"},{"location":"opcodes/findFileInPath.html#output","text":"Sout : the absolute path, or \"\" if not found","title":"Output"},{"location":"opcodes/findFileInPath.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/findFileInPath.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Sabspath findFileInPath Sfile Searched for Sfile, first in the current directory, then in the directories specified in SSDIR. Returns the absolute path or an empty string to signal that the file was not found. */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 ; find the directory of this script S path f indFileInPath \"findFileInPath.csd\" if strlen ( S path ) == 0 then i niterror \"Could not find file\" endif S dir , S base pathSplit S path prints \"Spath: %s \\n Folder: %s \\n \" , S path , S dir S value getEnvVar \"SSDIR\" prints \"SSDIR: %s \\n \" , S value S scriptdir scriptDir prints \"Directory of current script: %s \\n \" , S scriptdir turnoff endin </ CsInstruments > < CsScore > i 1 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/findFileInPath.html#see-also","text":"scriptDir","title":"See also"},{"location":"opcodes/findFileInPath.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/findarray.html","text":"findarray Abstract Find an element in an array Description findarray finds the index of an element in an array. If the element is not found it returns -1 Syntax i index f indarray i arr [], i val , i tolerance = 1e-12 k index f indarray k arr [], k val , i tolerance = 1e-12 i index f indarray S arr [], S val k index f indarray S arr [], S val Arguments iarr / karr / Sarr : A 1D array to search ival / kval / Sval : the value to search itolerance : A tolerance value. When using floats it is not recommended to check for equality but to check if two values are close enough Output iindex / kindex : the index of the value inside the array, or -1 if the value is not found Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound ; -odac </ CsOptions > < CsInstruments > /* Description =========== findarray return the index of the first element which is equal to the given number. If the number is not found, the return value is -1 Syntax ====== kidx findarray karray[], kvalue/ivalue [, iepsilon=1e-12] kidx findarray iarray[], kvalue [, iepsilon=1e-12] idx findarray iarray[], ivalue [, iepsilon=1e-12] idx findarray Sarray[], Svalue kidx findarray Sarray[], Svalue */ ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 k arr [] fillarray 0 , 0.5 , 0.3 , 10 , 0.8 k idx f indarray k arr , 0.3 println \"kidx: %d \" , k idx k arr2 [] genarray_i 0 , 100 , 0.1 k idx2 f indarray k arr2 , 70.8 println \"kidx2: %d \" , k idx2 turnoff endin instr 2 S arr [] strsplit \"Zero One Two Three Four Five Six Seven Eight Nine\" , \" \" i dx1 f indarray S arr , \"Three\" i dx2 f indarray S arr , \"Foo\" prints \"Indexx of Three: %d , index of Foo: %d \\n \" , i dx1 , i dx2 turnoff endin </ CsInstruments > < CsScore > i 1 0 0.1 i 2 0.1 0.1 </ CsScore > </ CsoundSynthesizer > See also ftfind strsplit dict_get Credits Eduardo Moguillansky, 2021","title":"findarray"},{"location":"opcodes/findarray.html#findarray","text":"","title":"findarray"},{"location":"opcodes/findarray.html#abstract","text":"Find an element in an array","title":"Abstract"},{"location":"opcodes/findarray.html#description","text":"findarray finds the index of an element in an array. If the element is not found it returns -1","title":"Description"},{"location":"opcodes/findarray.html#syntax","text":"i index f indarray i arr [], i val , i tolerance = 1e-12 k index f indarray k arr [], k val , i tolerance = 1e-12 i index f indarray S arr [], S val k index f indarray S arr [], S val","title":"Syntax"},{"location":"opcodes/findarray.html#arguments","text":"iarr / karr / Sarr : A 1D array to search ival / kval / Sval : the value to search itolerance : A tolerance value. When using floats it is not recommended to check for equality but to check if two values are close enough","title":"Arguments"},{"location":"opcodes/findarray.html#output","text":"iindex / kindex : the index of the value inside the array, or -1 if the value is not found","title":"Output"},{"location":"opcodes/findarray.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/findarray.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound ; -odac </ CsOptions > < CsInstruments > /* Description =========== findarray return the index of the first element which is equal to the given number. If the number is not found, the return value is -1 Syntax ====== kidx findarray karray[], kvalue/ivalue [, iepsilon=1e-12] kidx findarray iarray[], kvalue [, iepsilon=1e-12] idx findarray iarray[], ivalue [, iepsilon=1e-12] idx findarray Sarray[], Svalue kidx findarray Sarray[], Svalue */ ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 k arr [] fillarray 0 , 0.5 , 0.3 , 10 , 0.8 k idx f indarray k arr , 0.3 println \"kidx: %d \" , k idx k arr2 [] genarray_i 0 , 100 , 0.1 k idx2 f indarray k arr2 , 70.8 println \"kidx2: %d \" , k idx2 turnoff endin instr 2 S arr [] strsplit \"Zero One Two Three Four Five Six Seven Eight Nine\" , \" \" i dx1 f indarray S arr , \"Three\" i dx2 f indarray S arr , \"Foo\" prints \"Indexx of Three: %d , index of Foo: %d \\n \" , i dx1 , i dx2 turnoff endin </ CsInstruments > < CsScore > i 1 0 0.1 i 2 0.1 0.1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/findarray.html#see-also","text":"ftfind strsplit dict_get","title":"See also"},{"location":"opcodes/findarray.html#credits","text":"Eduardo Moguillansky, 2021","title":"Credits"},{"location":"opcodes/frac2int.html","text":"frac2int Abstract Convert the fractional part of a number into an integer Description frac2int can be used to convert the fractional part of a number (as passed, for example, as p1 ) back to an integer. Syntax i Int f rac2int i Float , i Mul k Int f rac2int k Float , k Mul Arguments iFloat / kFloat : a number with a fractional part (for example, a fractional p1 ) iMul / kMul : the factor used to convert the initial integer into a fraction (see example) Output iInt / kInt : the integer value corresponding to the fractional part Note The integral part of the passed value is discarded i val = 10 + 123 / 1000 ; => 10.123 i val2 f rac2int i val , 1000 ; => 123 Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > instr 1 i num f rac2int 1.45 , 100 print i num turnoff endin </ CsInstruments > < CsScore > i 1 0 0.1 ; f0 3600 </ CsScore > </ CsoundSynthesizer > See also frac Credits Eduardo Moguillansky, 2019","title":"frac2int"},{"location":"opcodes/frac2int.html#frac2int","text":"","title":"frac2int"},{"location":"opcodes/frac2int.html#abstract","text":"Convert the fractional part of a number into an integer","title":"Abstract"},{"location":"opcodes/frac2int.html#description","text":"frac2int can be used to convert the fractional part of a number (as passed, for example, as p1 ) back to an integer.","title":"Description"},{"location":"opcodes/frac2int.html#syntax","text":"i Int f rac2int i Float , i Mul k Int f rac2int k Float , k Mul","title":"Syntax"},{"location":"opcodes/frac2int.html#arguments","text":"iFloat / kFloat : a number with a fractional part (for example, a fractional p1 ) iMul / kMul : the factor used to convert the initial integer into a fraction (see example)","title":"Arguments"},{"location":"opcodes/frac2int.html#output","text":"iInt / kInt : the integer value corresponding to the fractional part Note The integral part of the passed value is discarded i val = 10 + 123 / 1000 ; => 10.123 i val2 f rac2int i val , 1000 ; => 123","title":"Output"},{"location":"opcodes/frac2int.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/frac2int.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > instr 1 i num f rac2int 1.45 , 100 print i num turnoff endin </ CsInstruments > < CsScore > i 1 0 0.1 ; f0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/frac2int.html#see-also","text":"frac","title":"See also"},{"location":"opcodes/frac2int.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/ftfill.html","text":"ftfill Abstract create a table and fill it with values (like fillarray but for f-tables) Description ftfill is a shortcut opcode to create a table and fill it with values. It explicitely disallows the user to set the table-number manually. Syntax i tabnum f tfill i 0 , [ i 1 , i 2 , ... ] Arguments ix : The value(s) to place in the f-table Output itabnum : the number of the generated f-table Execution Time Init Examples < CsoundSynthesizer > < CsOptions > ; -odac </ CsOptions > < CsInstruments > /* Description =========== ftfill creates a table and fills it with values. Like fillarray, but for f-tables. Syntax ====== itabnum ftfill x0, [x1, x2, ...] **NB**: this is the same as ``itabnum ftgen 0, 0, 0, -2, x0, x1, x2, ...`` */ ksmps = 32 nchnls = 2 0dbfs = 1 instr example1 i time2midi1 f tfill 0 , 64 , 4 , 62 , 5 , 62 , 6 , 67 i time2midi2 f tfill 0 , 60 , 4 , 60 , 5 , 59 , 6 , 59 ftprint i time2midi1 ftfree i time2midi1 , 1 ftfree i time2midi2 , 1 ; step=2, bisect the column 0. k t = timeinsts () k idx1 bisect k t , i time2midi1 , 2 k idx2 bisect k t , i time2midi2 , 2 ; -1: cosine interpolation, step size=2, offset=1 k midi1 i nterp1d k idx1 , i time2midi1 , \"cos\" , 2 , 1 k midi2 i nterp1d k idx2 , i time2midi2 , \"cos\" , 2 , 1 a 0 squinewave a ( mtof ( k midi1 )), a ( 0.1 ), a ( 0.1 ) a 1 squinewave a ( mtof ( k midi2 )), a ( 0.2 ), a ( 0.5 ) i gain = 0.1 i fade = 0.2 a env = linseg : a ( 0 , i fade , i gain , p3 - i fade * 2 - 0.1 , i gain , i fade , 0 ) outch 1 , a 0 * a env , 2 , a 1 * a env endin </ CsInstruments > < CsScore > i \"example1\" 0 1 </ CsScore > </ CsoundSynthesizer > See also ftgen fillarray ftnew ftfree Credits Eduardo Moguillansky, 2019","title":"ftfill"},{"location":"opcodes/ftfill.html#ftfill","text":"","title":"ftfill"},{"location":"opcodes/ftfill.html#abstract","text":"create a table and fill it with values (like fillarray but for f-tables)","title":"Abstract"},{"location":"opcodes/ftfill.html#description","text":"ftfill is a shortcut opcode to create a table and fill it with values. It explicitely disallows the user to set the table-number manually.","title":"Description"},{"location":"opcodes/ftfill.html#syntax","text":"i tabnum f tfill i 0 , [ i 1 , i 2 , ... ]","title":"Syntax"},{"location":"opcodes/ftfill.html#arguments","text":"ix : The value(s) to place in the f-table","title":"Arguments"},{"location":"opcodes/ftfill.html#output","text":"itabnum : the number of the generated f-table","title":"Output"},{"location":"opcodes/ftfill.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/ftfill.html#examples","text":"< CsoundSynthesizer > < CsOptions > ; -odac </ CsOptions > < CsInstruments > /* Description =========== ftfill creates a table and fills it with values. Like fillarray, but for f-tables. Syntax ====== itabnum ftfill x0, [x1, x2, ...] **NB**: this is the same as ``itabnum ftgen 0, 0, 0, -2, x0, x1, x2, ...`` */ ksmps = 32 nchnls = 2 0dbfs = 1 instr example1 i time2midi1 f tfill 0 , 64 , 4 , 62 , 5 , 62 , 6 , 67 i time2midi2 f tfill 0 , 60 , 4 , 60 , 5 , 59 , 6 , 59 ftprint i time2midi1 ftfree i time2midi1 , 1 ftfree i time2midi2 , 1 ; step=2, bisect the column 0. k t = timeinsts () k idx1 bisect k t , i time2midi1 , 2 k idx2 bisect k t , i time2midi2 , 2 ; -1: cosine interpolation, step size=2, offset=1 k midi1 i nterp1d k idx1 , i time2midi1 , \"cos\" , 2 , 1 k midi2 i nterp1d k idx2 , i time2midi2 , \"cos\" , 2 , 1 a 0 squinewave a ( mtof ( k midi1 )), a ( 0.1 ), a ( 0.1 ) a 1 squinewave a ( mtof ( k midi2 )), a ( 0.2 ), a ( 0.5 ) i gain = 0.1 i fade = 0.2 a env = linseg : a ( 0 , i fade , i gain , p3 - i fade * 2 - 0.1 , i gain , i fade , 0 ) outch 1 , a 0 * a env , 2 , a 1 * a env endin </ CsInstruments > < CsScore > i \"example1\" 0 1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/ftfill.html#see-also","text":"ftgen fillarray ftnew ftfree","title":"See also"},{"location":"opcodes/ftfill.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/ftfind.html","text":"ftfind Abstract Find an element in a table Description ftfind finds the index of an element in table. If the element is not found it returns -1 Syntax i index f tfind i tab , i val , i tolerance = 1e-12 k index f tfind k tab , k val , i tolerance = 1e-12 Arguments itab / ktab : A table ival / kval : The value to find itolerance : A tolerance value. When using floats it is not recommended to check for equality but to check if two values are close enough Output iindex / kindex : the index of the value inside the table, or -1 if the value is not found Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound ; -odac </ CsOptions > < CsInstruments > /* Description =========== ftfind return the index of the first element in a table which is equal to the given number. If the number is not found, the return value is -1 Syntax ====== kidx ftfind ktabnum, kvalue, iepsilon=1e-12 iidx ftfind itabnum, ivalue, iepsilon=1e-12 */ ksmps = 64 nchnls = 2 0dbfs = 1 instr 10 i tabnum f tfill 0 , 0.5 , 0.3 , 10 , 0.8 i idx f tfind i tabnum , 0.3 prints \"iidx: %d \\n \" , i idx turnoff endin </ CsInstruments > < CsScore > i 10 0 0.1 </ CsScore > </ CsoundSynthesizer > See also findarray Credits Eduardo Moguillansky, 2021","title":"ftfind"},{"location":"opcodes/ftfind.html#ftfind","text":"","title":"ftfind"},{"location":"opcodes/ftfind.html#abstract","text":"Find an element in a table","title":"Abstract"},{"location":"opcodes/ftfind.html#description","text":"ftfind finds the index of an element in table. If the element is not found it returns -1","title":"Description"},{"location":"opcodes/ftfind.html#syntax","text":"i index f tfind i tab , i val , i tolerance = 1e-12 k index f tfind k tab , k val , i tolerance = 1e-12","title":"Syntax"},{"location":"opcodes/ftfind.html#arguments","text":"itab / ktab : A table ival / kval : The value to find itolerance : A tolerance value. When using floats it is not recommended to check for equality but to check if two values are close enough","title":"Arguments"},{"location":"opcodes/ftfind.html#output","text":"iindex / kindex : the index of the value inside the table, or -1 if the value is not found","title":"Output"},{"location":"opcodes/ftfind.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/ftfind.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound ; -odac </ CsOptions > < CsInstruments > /* Description =========== ftfind return the index of the first element in a table which is equal to the given number. If the number is not found, the return value is -1 Syntax ====== kidx ftfind ktabnum, kvalue, iepsilon=1e-12 iidx ftfind itabnum, ivalue, iepsilon=1e-12 */ ksmps = 64 nchnls = 2 0dbfs = 1 instr 10 i tabnum f tfill 0 , 0.5 , 0.3 , 10 , 0.8 i idx f tfind i tabnum , 0.3 prints \"iidx: %d \\n \" , i idx turnoff endin </ CsInstruments > < CsScore > i 10 0 0.1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/ftfind.html#see-also","text":"findarray","title":"See also"},{"location":"opcodes/ftfind.html#credits","text":"Eduardo Moguillansky, 2021","title":"Credits"},{"location":"opcodes/ftnew.html","text":"ftnew Abstract creates a new table of a given size Description ftnew is a shortcut opcode to create a new table of a given size. It is possible to set the elements to an initial value (default=0). It explicitely disallows the user to set the table-number manually. Syntax i tabnum f tnew i size , [ i default = 0 ] Arguments isize : The size of the table. idefault : The initial value for all items in the table (default=0) Output itabnum : the number of the generated f-table Execution Time Init Examples ; create a table from an array of any size i xs [] fillarray 0 , 1 , 2 , 3 , 4 , 5 i tab f tnew lenarray ( i xs ) copya2ftab i xs , i tab See also ftgen fillarray ftfill ftfree Credits Eduardo Moguillansky, 2021","title":"ftnew"},{"location":"opcodes/ftnew.html#ftnew","text":"","title":"ftnew"},{"location":"opcodes/ftnew.html#abstract","text":"creates a new table of a given size","title":"Abstract"},{"location":"opcodes/ftnew.html#description","text":"ftnew is a shortcut opcode to create a new table of a given size. It is possible to set the elements to an initial value (default=0). It explicitely disallows the user to set the table-number manually.","title":"Description"},{"location":"opcodes/ftnew.html#syntax","text":"i tabnum f tnew i size , [ i default = 0 ]","title":"Syntax"},{"location":"opcodes/ftnew.html#arguments","text":"isize : The size of the table. idefault : The initial value for all items in the table (default=0)","title":"Arguments"},{"location":"opcodes/ftnew.html#output","text":"itabnum : the number of the generated f-table","title":"Output"},{"location":"opcodes/ftnew.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/ftnew.html#examples","text":"; create a table from an array of any size i xs [] fillarray 0 , 1 , 2 , 3 , 4 , 5 i tab f tnew lenarray ( i xs ) copya2ftab i xs , i tab","title":"Examples"},{"location":"opcodes/ftnew.html#see-also","text":"ftgen fillarray ftfill ftfree","title":"See also"},{"location":"opcodes/ftnew.html#credits","text":"Eduardo Moguillansky, 2021","title":"Credits"},{"location":"opcodes/ftsetparams.html","text":"ftsetparams Abstract Set metadata parameters of a table, as if it was loaded via GEN1 Description ftsetparams can be used to set the parameters set via when reading a table via GEN1 (samplerate, number of channels, looping, etc). This are necessary by some opcodes (loscil, for example) to play correctly. Together with ftslice it can be used to extract a channel of a multichannel table preserving the table metadata. Syntax f tsetparams i ft , i samplerate , i numchannels , i loopstart = 0 , i basenote = 60 Arguments ift : the table number to modify isamplerate : the sample rate of the data saved in the table inumchannels : the number of channels of the audio sample iloopstart : if this is a loop, start of the sustain part ibasenote : pitch of the sample, as midinote Output Execution Time Init Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 gi func0 ftgen 0 , 0 , 0 , - 1 , \"musicbox.flac\" , 0 , 0 , 0 gi 1 ftgen 0 , 0 , nsamp ( gi func0 ), 2 , 0 ftslicei gi func0 , gi 1 , 0 , 0 , 2 f tsetparams gi 1 , ftsr : i ( gi func0 ), 1 gi 2 ftgen 0 , 0 , nsamp ( gi func0 ), 2 , 0 ftslicei gi func0 , gi 2 , 1 , 0 , 2 f tsetparams gi 2 , ftsr : i ( gi func0 ), 1 instr 1 a 0 , a 1 loscil 1 , 1 , gi func0 , 1 outch 1 , a 0 , 2 , a 1 endin instr 2 a 0 loscil 1 , 1 , gi 1 , 1 a 1 loscil 1 , 1 , gi 2 , 1 outch 1 , a 0 , 2 , a 1 endin ; schedule(1, 0, -1) schedule ( 2 , 0 , - 1 ) </ CsInstruments > < CsScore > </ CsScore > </ CsoundSynthesizer > See also ftslice ftslicei loscil ftsr ftchnls Credits Eduardo Moguillansky, 2020","title":"ftsetparams"},{"location":"opcodes/ftsetparams.html#ftsetparams","text":"","title":"ftsetparams"},{"location":"opcodes/ftsetparams.html#abstract","text":"Set metadata parameters of a table, as if it was loaded via GEN1","title":"Abstract"},{"location":"opcodes/ftsetparams.html#description","text":"ftsetparams can be used to set the parameters set via when reading a table via GEN1 (samplerate, number of channels, looping, etc). This are necessary by some opcodes (loscil, for example) to play correctly. Together with ftslice it can be used to extract a channel of a multichannel table preserving the table metadata.","title":"Description"},{"location":"opcodes/ftsetparams.html#syntax","text":"f tsetparams i ft , i samplerate , i numchannels , i loopstart = 0 , i basenote = 60","title":"Syntax"},{"location":"opcodes/ftsetparams.html#arguments","text":"ift : the table number to modify isamplerate : the sample rate of the data saved in the table inumchannels : the number of channels of the audio sample iloopstart : if this is a loop, start of the sustain part ibasenote : pitch of the sample, as midinote","title":"Arguments"},{"location":"opcodes/ftsetparams.html#output","text":"","title":"Output"},{"location":"opcodes/ftsetparams.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/ftsetparams.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 gi func0 ftgen 0 , 0 , 0 , - 1 , \"musicbox.flac\" , 0 , 0 , 0 gi 1 ftgen 0 , 0 , nsamp ( gi func0 ), 2 , 0 ftslicei gi func0 , gi 1 , 0 , 0 , 2 f tsetparams gi 1 , ftsr : i ( gi func0 ), 1 gi 2 ftgen 0 , 0 , nsamp ( gi func0 ), 2 , 0 ftslicei gi func0 , gi 2 , 1 , 0 , 2 f tsetparams gi 2 , ftsr : i ( gi func0 ), 1 instr 1 a 0 , a 1 loscil 1 , 1 , gi func0 , 1 outch 1 , a 0 , 2 , a 1 endin instr 2 a 0 loscil 1 , 1 , gi 1 , 1 a 1 loscil 1 , 1 , gi 2 , 1 outch 1 , a 0 , 2 , a 1 endin ; schedule(1, 0, -1) schedule ( 2 , 0 , - 1 ) </ CsInstruments > < CsScore > </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/ftsetparams.html#see-also","text":"ftslice ftslicei loscil ftsr ftchnls","title":"See also"},{"location":"opcodes/ftsetparams.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/getEnvVar.html","text":"getEnvVar Abstract Get the value of an environment variable Description getEnvVar first checks csound own environment and if the variable is not defined checks the global environment. If the variable is not defined, returns an empty string Note Csound updates its environment when passed flags like --env:NAME=value or --env:NAME+=value . Also csound adds the directory of an orchestra loaded at start time to its own path variables, like SSDIR, SADIR, etc. This opcode will reflect those changes Syntax Svalue getEnvVar Svarname Arguments `Svarname': The name of the env variable, something like \"SSDIR\" or \"USER\" Output Svalue : the value of the variable, if defined (an empty string otherwise) Execution Time Init Examples ; Get the value of the HOME env variable S home getEnvVar \"HOME\" ; and the actual value of INCDIR S incdir getEnvVar \"INCDIR\" prints \"HOME: %s , INCDIR: %s \\n \" , S home , S incdir See also system Credits Eduardo Moguillansky, 2020","title":"getEnvVar"},{"location":"opcodes/getEnvVar.html#getenvvar","text":"","title":"getEnvVar"},{"location":"opcodes/getEnvVar.html#abstract","text":"Get the value of an environment variable","title":"Abstract"},{"location":"opcodes/getEnvVar.html#description","text":"getEnvVar first checks csound own environment and if the variable is not defined checks the global environment. If the variable is not defined, returns an empty string Note Csound updates its environment when passed flags like --env:NAME=value or --env:NAME+=value . Also csound adds the directory of an orchestra loaded at start time to its own path variables, like SSDIR, SADIR, etc. This opcode will reflect those changes","title":"Description"},{"location":"opcodes/getEnvVar.html#syntax","text":"Svalue getEnvVar Svarname","title":"Syntax"},{"location":"opcodes/getEnvVar.html#arguments","text":"`Svarname': The name of the env variable, something like \"SSDIR\" or \"USER\"","title":"Arguments"},{"location":"opcodes/getEnvVar.html#output","text":"Svalue : the value of the variable, if defined (an empty string otherwise)","title":"Output"},{"location":"opcodes/getEnvVar.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/getEnvVar.html#examples","text":"; Get the value of the HOME env variable S home getEnvVar \"HOME\" ; and the actual value of INCDIR S incdir getEnvVar \"INCDIR\" prints \"HOME: %s , INCDIR: %s \\n \" , S home , S incdir","title":"Examples"},{"location":"opcodes/getEnvVar.html#see-also","text":"system","title":"See also"},{"location":"opcodes/getEnvVar.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/initerror.html","text":"initerror Abstract Throws an error message at init Description Use initerror to stop the current event with an init error Syntax initerror Smessage Arguments Smessage : the text message to show. Use sprintf to construct a message if needed Output Execution Time Init Examples if i midi > 128 then i niterror sprintf ( \"Received an invalid midi value ( %d )\" , i midi ) endif See also throwerror Credits Eduardo Moguillansky, 2020","title":"initerror"},{"location":"opcodes/initerror.html#initerror","text":"","title":"initerror"},{"location":"opcodes/initerror.html#abstract","text":"Throws an error message at init","title":"Abstract"},{"location":"opcodes/initerror.html#description","text":"Use initerror to stop the current event with an init error","title":"Description"},{"location":"opcodes/initerror.html#syntax","text":"initerror Smessage","title":"Syntax"},{"location":"opcodes/initerror.html#arguments","text":"Smessage : the text message to show. Use sprintf to construct a message if needed","title":"Arguments"},{"location":"opcodes/initerror.html#output","text":"","title":"Output"},{"location":"opcodes/initerror.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/initerror.html#examples","text":"if i midi > 128 then i niterror sprintf ( \"Received an invalid midi value ( %d )\" , i midi ) endif","title":"Examples"},{"location":"opcodes/initerror.html#see-also","text":"throwerror","title":"See also"},{"location":"opcodes/initerror.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/interp1d.html","text":"interp1d Abstract Interpolate between elements of an array/table Description Given a fractional index into an arra/table, interpolate between adjacent items. In the case of a table, a specific column of the table can be selected for performing interpolation. In this case, the index indicates the \"row\", the step value determines the size of each row, and the offset determines which column is used when interpolating. Possible interpolation modes are: linear, cos, floor, exponential and cubic. Together with bisect it can be used to generate any possible breakpoint-function configuration. NB : interp1d performs the opossite operation of bisect NB2 : when used with a table the param value can be given within the string, as \"exp=1.5\" or \"smooth=0.7\". For example, kout = interp1d(kidx, itab, \"exp=1.5\") Note At the moment the interpolation mode is set at init time and can't be modified Syntax k out i nterp1d k idx , xarr [], S mode = \"linear\" , k param = 0 a out i nterp1d a idx , xarr [], S mode = \"linear\" , k param = 0 i out i nterp1d i idx , i arr [], S mode = \"linear\" , k param = 0 k out [] i nterp1d k idx [], xarr [], S mode = \"linear\" , k param = 0 i out [] i nterp1d i idx [], i arr [], S mode = \"linear\" , k param = 0 k out i nterp1d k idx , k tab , S mode = \"linear\" , k step = 1 , k offset = 0 a out i nterp1d a idx , k tab , S mode = \"linear\" , k step = 1 , k offset = 0 i out i nterp1d i idx , i tab , S mode = \"linear\" , k step = 1 , k offset = 0 k out [] i nterp1d k idx [], k tab , S mode = \"linear\" , k step = 1 , k offset = 0 i out [] i nterp1d i idx [], k tab , S mode = \"linear\" , k step = 1 , k offset = 0 Arguments idx : the index into the array/table. For example, using linear interpolation (see mode) an index of 1.5 will interpolate halfway between arr[1] and arr[2] arr : the array (1D) holding the data. tab : the table holding the data mode : the interpolation mode. Possible interpolations modes are: \"linear\", \"cos\", \"floor\", \"cubic\", \"smooth\" (smoothstep, see https://en.wikipedia.org/wiki/Smoothstep), \"smoother\" (perlin's smootherstep) or \"exp\" (exponential). \"smoother\" interpolation is almost equal to \"smooth\" with param=0.7. param : a parameter used by the interpolation mode. In \"exp\" mode, param sets the exponent (2 will result in a quadratic curve). In \"smooth\" mode, param sets the number of extra smoothsteps (default=0). Fractional smoothsteps are possible (see ) Output out : the result of interpolating the array/table at the given index. Examples < CsoundSynthesizer > < CsOptions > ; -odac </ CsOptions > < CsInstruments > /* Abstract ======== Interpolate between elements of an array/table Syntax ====== kout interp1d kidx, xarr[], Smode=\"linear\", kparam=0 aout interp1d aidx, xarr[], Smode=\"linear\", kparam=0 iout interp1d iidx, iarr[], Smode=\"linear\", kparam=0 kout[] interp1d kidx[], xarr[], Smode=\"linear\", kparam=0 iout[] interp1d iidx[], iarr[], Smode=\"linear\", kparam=0 kout interp1d kidx, ktab, Smode=\"linear\", kstep=1, koffset=0 aout interp1d aidx, ktab, Smode=\"linear\", kstep=1, koffset=0 iout interp1d iidx, itab, Smode=\"linear\", kstep=1, koffset=0 kout[] interp1d kidx[], ktab, Smode=\"linear\", kstep=1, koffset=0 iout[] interp1d iidx[], ktab, Smode=\"linear\", kstep=1, koffset=0 **NB**: interp1d performs the opposite operation of `bisect` See Also ======== bisect, bpf, linlin, getrowlin, linenv */ ksmps = 10 nchnls = 2 0dbfs = 1 instr example1 i xs [] fillarray 0 , 10 , 16 , 18 , 28 ; interpolate ixs between at index 1.5, interpolating linearly between ; ixs[1] and ixs[2] i out i nterp1d 1.5 , i xs print i out ; -> 13. ; scan ixs at k-rate k idx = line : k ( 0 , p3 , lenarray : i ( i xs ) - 1 ) k out2 i nterp1d k idx , i xs println \"kidx: %f , kout2: %f \" , k idx , k out2 endin instr example2 ; used together with bisect can create multiple piecewise interpolation configurations i times [] fillarray 0 , 4 , 5 , 10 i midi1 [] fillarray 64 , 64 , 63.5 , 64.5 i midi2 [] fillarray 64 , 63.4 , 63.4 , 63 i amps [] fillarray 0 , 0.8 , 0.8 , 0 k idx bisect timeinsts (), i times k amp i nterp1d k idx , i amps , \"cos\" a amp interp k amp a 1 oscili a amp , mtof ( i nterp1d ( k idx , i midi1 , \"cubic\" )) a 2 oscili a amp , mtof ( i nterp1d ( k idx , i midi2 )) println \"amp: %f \" , rms : k ( a amp ) outch 1 , a 1 , 2 , a 2 endin instr example3 ; a table can also be used with interp1d / bisect. A table can hold ; both x and y coordinates as pairs i time2midi1 f tfill 0 , 64 , 4 , 62 , 5 , 62 , 6 , 67 i time2midi2 f tfill 0 , 60 , 4 , 60 , 5 , 59 , 6 , 59 ftfree i time2midi1 , 1 ftfree i time2midi2 , 1 ; step=2, bisect the column 0. k t = timeinsts () k idx1 bisect k t , i time2midi1 , 2 k idx2 bisect k t , i time2midi2 , 2 ; -1: cosine interpolation, step size=2, offset=1 k midi1 i nterp1d k idx1 , i time2midi1 , \"cos\" , 2 , 1 k midi2 i nterp1d k idx2 , i time2midi2 , \"cos\" , 2 , 1 a 0 squinewave a ( mtof ( k midi1 )), a ( 0.1 ), a ( 0.1 ) a 1 squinewave a ( mtof ( k midi2 )), a ( 0.2 ), a ( 0.5 ) i gain = 0.1 i fade = 0.2 a env = linseg : a ( 0 , i fade , i gain , p3 - i fade * 2 - 0.1 , i gain , i fade , 0 ) outch 1 , a 0 * a env , 2 , a 1 * a env endin instr example4 ; test all curves, save to csv i file fiopen \"interp1d.csv\" , 0 fprints i file , \"# kx, kidx, klin, kcos, kfloor, kcub, kexp, ksmooth, ksmooth2, ksmoother \\n \" i xs [] fillarray 0 , 1 , 4 , 5 , 6.4 , 8 i ys [] fillarray 0 , 10 , 2 , 20 , 3.2 , 16 k x line 0 , p3 , i xs [ lenarray ( i xs ) - 1 ] k idx bisect k x , i xs k lin = i nterp1d ( k idx , i ys , \"linear\" ) k cos i nterp1d k idx , i ys , \"cos\" k floor i nterp1d k idx , i ys , \"floor\" k cub = lag ( i nterp1d ( k idx , i ys , \"cubic\" ), 0.1 ) k exp i nterp1d k idx , i ys , \"exp\" , 2 k smooth i nterp1d k idx , i ys , \"smooth\" , 0 k smooth2 i nterp1d k idx , i ys , \"smooth\" , 1 k smoother i nterp1d k idx , i ys , \"smoother\" ; kx, kidx, klin, kcos, kfloor, kcub, kexp[O[I]] fprintks i file , \" %g , %g , %g , %g , %g , %g , %g , %g , %g , %g \\n \" , k x , k idx , k lin , k cos , k floor , k cub , k exp , k smooth , k smooth2 , k smoother endin </ CsInstruments > < CsScore > ; Uncomment to perform each example ; i \"example1\" 0 1 ; i \"example2\" 0 10 ;i \"example3\" 0 7 i \"example4\" 0 2 </ CsScore > </ CsoundSynthesizer > See Also bisect bpf linlin getrowlin linenv","title":"interp1d"},{"location":"opcodes/interp1d.html#interp1d","text":"","title":"interp1d"},{"location":"opcodes/interp1d.html#abstract","text":"Interpolate between elements of an array/table","title":"Abstract"},{"location":"opcodes/interp1d.html#description","text":"Given a fractional index into an arra/table, interpolate between adjacent items. In the case of a table, a specific column of the table can be selected for performing interpolation. In this case, the index indicates the \"row\", the step value determines the size of each row, and the offset determines which column is used when interpolating. Possible interpolation modes are: linear, cos, floor, exponential and cubic. Together with bisect it can be used to generate any possible breakpoint-function configuration. NB : interp1d performs the opossite operation of bisect NB2 : when used with a table the param value can be given within the string, as \"exp=1.5\" or \"smooth=0.7\". For example, kout = interp1d(kidx, itab, \"exp=1.5\") Note At the moment the interpolation mode is set at init time and can't be modified","title":"Description"},{"location":"opcodes/interp1d.html#syntax","text":"k out i nterp1d k idx , xarr [], S mode = \"linear\" , k param = 0 a out i nterp1d a idx , xarr [], S mode = \"linear\" , k param = 0 i out i nterp1d i idx , i arr [], S mode = \"linear\" , k param = 0 k out [] i nterp1d k idx [], xarr [], S mode = \"linear\" , k param = 0 i out [] i nterp1d i idx [], i arr [], S mode = \"linear\" , k param = 0 k out i nterp1d k idx , k tab , S mode = \"linear\" , k step = 1 , k offset = 0 a out i nterp1d a idx , k tab , S mode = \"linear\" , k step = 1 , k offset = 0 i out i nterp1d i idx , i tab , S mode = \"linear\" , k step = 1 , k offset = 0 k out [] i nterp1d k idx [], k tab , S mode = \"linear\" , k step = 1 , k offset = 0 i out [] i nterp1d i idx [], k tab , S mode = \"linear\" , k step = 1 , k offset = 0","title":"Syntax"},{"location":"opcodes/interp1d.html#arguments","text":"idx : the index into the array/table. For example, using linear interpolation (see mode) an index of 1.5 will interpolate halfway between arr[1] and arr[2] arr : the array (1D) holding the data. tab : the table holding the data mode : the interpolation mode. Possible interpolations modes are: \"linear\", \"cos\", \"floor\", \"cubic\", \"smooth\" (smoothstep, see https://en.wikipedia.org/wiki/Smoothstep), \"smoother\" (perlin's smootherstep) or \"exp\" (exponential). \"smoother\" interpolation is almost equal to \"smooth\" with param=0.7. param : a parameter used by the interpolation mode. In \"exp\" mode, param sets the exponent (2 will result in a quadratic curve). In \"smooth\" mode, param sets the number of extra smoothsteps (default=0). Fractional smoothsteps are possible (see )","title":"Arguments"},{"location":"opcodes/interp1d.html#output","text":"out : the result of interpolating the array/table at the given index.","title":"Output"},{"location":"opcodes/interp1d.html#examples","text":"< CsoundSynthesizer > < CsOptions > ; -odac </ CsOptions > < CsInstruments > /* Abstract ======== Interpolate between elements of an array/table Syntax ====== kout interp1d kidx, xarr[], Smode=\"linear\", kparam=0 aout interp1d aidx, xarr[], Smode=\"linear\", kparam=0 iout interp1d iidx, iarr[], Smode=\"linear\", kparam=0 kout[] interp1d kidx[], xarr[], Smode=\"linear\", kparam=0 iout[] interp1d iidx[], iarr[], Smode=\"linear\", kparam=0 kout interp1d kidx, ktab, Smode=\"linear\", kstep=1, koffset=0 aout interp1d aidx, ktab, Smode=\"linear\", kstep=1, koffset=0 iout interp1d iidx, itab, Smode=\"linear\", kstep=1, koffset=0 kout[] interp1d kidx[], ktab, Smode=\"linear\", kstep=1, koffset=0 iout[] interp1d iidx[], ktab, Smode=\"linear\", kstep=1, koffset=0 **NB**: interp1d performs the opposite operation of `bisect` See Also ======== bisect, bpf, linlin, getrowlin, linenv */ ksmps = 10 nchnls = 2 0dbfs = 1 instr example1 i xs [] fillarray 0 , 10 , 16 , 18 , 28 ; interpolate ixs between at index 1.5, interpolating linearly between ; ixs[1] and ixs[2] i out i nterp1d 1.5 , i xs print i out ; -> 13. ; scan ixs at k-rate k idx = line : k ( 0 , p3 , lenarray : i ( i xs ) - 1 ) k out2 i nterp1d k idx , i xs println \"kidx: %f , kout2: %f \" , k idx , k out2 endin instr example2 ; used together with bisect can create multiple piecewise interpolation configurations i times [] fillarray 0 , 4 , 5 , 10 i midi1 [] fillarray 64 , 64 , 63.5 , 64.5 i midi2 [] fillarray 64 , 63.4 , 63.4 , 63 i amps [] fillarray 0 , 0.8 , 0.8 , 0 k idx bisect timeinsts (), i times k amp i nterp1d k idx , i amps , \"cos\" a amp interp k amp a 1 oscili a amp , mtof ( i nterp1d ( k idx , i midi1 , \"cubic\" )) a 2 oscili a amp , mtof ( i nterp1d ( k idx , i midi2 )) println \"amp: %f \" , rms : k ( a amp ) outch 1 , a 1 , 2 , a 2 endin instr example3 ; a table can also be used with interp1d / bisect. A table can hold ; both x and y coordinates as pairs i time2midi1 f tfill 0 , 64 , 4 , 62 , 5 , 62 , 6 , 67 i time2midi2 f tfill 0 , 60 , 4 , 60 , 5 , 59 , 6 , 59 ftfree i time2midi1 , 1 ftfree i time2midi2 , 1 ; step=2, bisect the column 0. k t = timeinsts () k idx1 bisect k t , i time2midi1 , 2 k idx2 bisect k t , i time2midi2 , 2 ; -1: cosine interpolation, step size=2, offset=1 k midi1 i nterp1d k idx1 , i time2midi1 , \"cos\" , 2 , 1 k midi2 i nterp1d k idx2 , i time2midi2 , \"cos\" , 2 , 1 a 0 squinewave a ( mtof ( k midi1 )), a ( 0.1 ), a ( 0.1 ) a 1 squinewave a ( mtof ( k midi2 )), a ( 0.2 ), a ( 0.5 ) i gain = 0.1 i fade = 0.2 a env = linseg : a ( 0 , i fade , i gain , p3 - i fade * 2 - 0.1 , i gain , i fade , 0 ) outch 1 , a 0 * a env , 2 , a 1 * a env endin instr example4 ; test all curves, save to csv i file fiopen \"interp1d.csv\" , 0 fprints i file , \"# kx, kidx, klin, kcos, kfloor, kcub, kexp, ksmooth, ksmooth2, ksmoother \\n \" i xs [] fillarray 0 , 1 , 4 , 5 , 6.4 , 8 i ys [] fillarray 0 , 10 , 2 , 20 , 3.2 , 16 k x line 0 , p3 , i xs [ lenarray ( i xs ) - 1 ] k idx bisect k x , i xs k lin = i nterp1d ( k idx , i ys , \"linear\" ) k cos i nterp1d k idx , i ys , \"cos\" k floor i nterp1d k idx , i ys , \"floor\" k cub = lag ( i nterp1d ( k idx , i ys , \"cubic\" ), 0.1 ) k exp i nterp1d k idx , i ys , \"exp\" , 2 k smooth i nterp1d k idx , i ys , \"smooth\" , 0 k smooth2 i nterp1d k idx , i ys , \"smooth\" , 1 k smoother i nterp1d k idx , i ys , \"smoother\" ; kx, kidx, klin, kcos, kfloor, kcub, kexp[O[I]] fprintks i file , \" %g , %g , %g , %g , %g , %g , %g , %g , %g , %g \\n \" , k x , k idx , k lin , k cos , k floor , k cub , k exp , k smooth , k smooth2 , k smoother endin </ CsInstruments > < CsScore > ; Uncomment to perform each example ; i \"example1\" 0 1 ; i \"example2\" 0 10 ;i \"example3\" 0 7 i \"example4\" 0 2 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/interp1d.html#see-also","text":"bisect bpf linlin getrowlin linenv","title":"See Also"},{"location":"opcodes/lfnoise.html","text":"lfnoise Abstract low frequency, band-limited noise Description Generates random values at a rate given by the nearest integer division of the sample rate by the freq argument. If kinterp==0, between generated values 0 is output. Otherwise the output is the result of interpolating between the generated values. Output is always band limited. Syntax a out lfnoise k rate , k interp = 0 Arguments krate : the frequency to generate new values kinterp : if 1, the output is the result of linear interpolation between the generated values Output aout : if kinterp==0, then this is the output random values at the given frequency, or 0. If kinterp==1, then output is the result of interpolation between two generated values. Execution Time Performance Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* Example file for lfnoise lfnoise generates a random value between 0-1 at the given frequency. If kinterp=1, then values are interpolated; otherwise, they are held until next value */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 FLpanel \"lfnoise\" , 400 , 200 , 50 , 50 i disp1 FLvalue \"\" , 50 , 30 , 322 , 20 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk freq , i h1 FLslider \"freq\" , 0 , 200 , 0 , 3 , i disp1 , 300 , 30 , 20 , 20 gk interp , i h2 FLbutton \"interpolate\" , 1 , 0 , 3 , 100 , 50 , 20 , 80 , - 1 gk gain , i h3 FLslider \"gain\" , 0 , 1 , 0 , 3 , - 1 , 300 , 30 , 20 , 140 FLpanelEnd FLrun FLsetVal_i 8 , i h1 FLsetVal_i 0.1 , i h3 instr 1 a out lfnoise gk freq , gk interp a out *= interp ( gk gain ) outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer > See also dust2 crackle Credits Eduardo Moguillansky, 2019 (port of pd/else's lfnoise , which is itself a merge of supercollider's LFNoise0 and LFNoise1 )","title":"lfnoise"},{"location":"opcodes/lfnoise.html#lfnoise","text":"","title":"lfnoise"},{"location":"opcodes/lfnoise.html#abstract","text":"low frequency, band-limited noise","title":"Abstract"},{"location":"opcodes/lfnoise.html#description","text":"Generates random values at a rate given by the nearest integer division of the sample rate by the freq argument. If kinterp==0, between generated values 0 is output. Otherwise the output is the result of interpolating between the generated values. Output is always band limited.","title":"Description"},{"location":"opcodes/lfnoise.html#syntax","text":"a out lfnoise k rate , k interp = 0","title":"Syntax"},{"location":"opcodes/lfnoise.html#arguments","text":"krate : the frequency to generate new values kinterp : if 1, the output is the result of linear interpolation between the generated values","title":"Arguments"},{"location":"opcodes/lfnoise.html#output","text":"aout : if kinterp==0, then this is the output random values at the given frequency, or 0. If kinterp==1, then output is the result of interpolation between two generated values.","title":"Output"},{"location":"opcodes/lfnoise.html#execution-time","text":"Performance","title":"Execution Time"},{"location":"opcodes/lfnoise.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* Example file for lfnoise lfnoise generates a random value between 0-1 at the given frequency. If kinterp=1, then values are interpolated; otherwise, they are held until next value */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 FLpanel \"lfnoise\" , 400 , 200 , 50 , 50 i disp1 FLvalue \"\" , 50 , 30 , 322 , 20 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk freq , i h1 FLslider \"freq\" , 0 , 200 , 0 , 3 , i disp1 , 300 , 30 , 20 , 20 gk interp , i h2 FLbutton \"interpolate\" , 1 , 0 , 3 , 100 , 50 , 20 , 80 , - 1 gk gain , i h3 FLslider \"gain\" , 0 , 1 , 0 , 3 , - 1 , 300 , 30 , 20 , 140 FLpanelEnd FLrun FLsetVal_i 8 , i h1 FLsetVal_i 0.1 , i h3 instr 1 a out lfnoise gk freq , gk interp a out *= interp ( gk gain ) outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/lfnoise.html#see-also","text":"dust2 crackle","title":"See also"},{"location":"opcodes/lfnoise.html#credits","text":"Eduardo Moguillansky, 2019 (port of pd/else's lfnoise , which is itself a merge of supercollider's LFNoise0 and LFNoise1 )","title":"Credits"},{"location":"opcodes/linenv.html","text":"linenv Abstract A triggerable linear envelope with sustain segment Description linenv is similar to linsegr with an additional gate argument, allowing to retrigger it at will. One of the values can be defined as a sustain point, meaning that as long as the gate is held, the envelope enters a sustain state when reaching this point. When the gate is set to 0, the envelope traverses the rest of the defined points. If the gate is closed before reaching the sustain segment, the envelope slides to the release section skipping any segments in between. Warning Unlike linsegr , linenv does not extend the time of the instrument. Use xtratim for that Note Similarly to linseg/linsegr, it is possible to define segments of 0 duration to force sharp jumps Syntax xout linenv k gate , i sustindex , k val0 , [ k time1 , k val1 , k time2 , k val2 , ... ] Arguments kgate : whenever this switches from 0 to 1 a new envelope starts. If a sustain segment was defined, when closing the gate (transition from 1 to 0) the envelope jumps to the sustain segment. Otherwise it just continues until it reaches the last segment (a \"oneshot\" envelope) isustindex : the index of the sustain point. For example, if isustindex is 2, then when the envelope reaches kval2 (after ktime0+ktime1), it enters a sustain phase, where its value remains unmodified until the gate is set to 0. If no sustain point is desired, set isustindex to 0. NB : negative values count from end. To imitate the behaviour of linsegr, use -1 as sustain index. kval0 , ktime1 , ...: a linear envelope, similar to linsegr . The release part can have as many segments as desired. ktime n values are defined as time interval between two values, not as absolute timestamps Output xout : value of the envelope (k- or a- rate) Execution Time Performance Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* This is the example file for opcode \"linenv\" linenv is a triggerable envelope with a sustain segment aout linenv kgate, isustidx, kval0, ktime1, kval1, ..., ktimen, kvaln NB: use xtratim if necessary to allow for release segment */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 gk gate init 0 FLpanel \"linenv\" , 240 , 100 , 100 , 100 gk gate , gi h1 FLbutton \" Gate\" , 1 , 0 , 2 , 80 , 40 , 10 , 10 , - 1 FLpanelEnd FLrun instr 1 k gate = trighold : k ( metro ( 1 / 2 ), 0.5 ) k env linenv k gate , 1 , 0 , 0.15 , 1 , 0.1 , 0 printf \"t: %f , kenv: %f \\n \" , timeinstk (), timeinsts (), k env k env *= 0.2 a sig = pinker () * interp ( k env ) outs a sig , a sig endin instr 2 i period = 2 i gatedur = 1 k gate = trighold : k ( metro ( 1 / i period ), i gatedur ) a env linenv k gate , - 2 , 0 , 0.05 , 1 , 0.2 , 0.5 , 0.2 , 1 , 0.4 , 0 a sig = oscili : a ( 0.2 , 1000 ) * a env FLsetVal changed ( k gate ), k gate , gi h1 outs a sig , a sig endin instr 3 a sig pinker a env linenv gk gate , 2 , 0 , 0.05 , 1 , 0.1 , 0.2 , 0.5 , 0 a sig *= a env outs a sig , a sig endin instr 4 ; no sustain (\"one shot\") a sig pinker a env linenv gk gate , 0 , 0 , 0.05 , 1 , 0.1 , 0.2 , 0.5 , 0 a sig *= a env outs a sig , a sig endin </ CsInstruments > < CsScore > ; i1 0 10 ; i2 0 10 i 3 0 100 ; i4 0 100 </ CsScore > </ CsoundSynthesizer > See also ramptrig bisect interp1d bpf linsegr Credits Eduardo Moguillansky, 2019 (idea based on pd/else's envgen and supercollider's envgen )","title":"linenv"},{"location":"opcodes/linenv.html#linenv","text":"","title":"linenv"},{"location":"opcodes/linenv.html#abstract","text":"A triggerable linear envelope with sustain segment","title":"Abstract"},{"location":"opcodes/linenv.html#description","text":"linenv is similar to linsegr with an additional gate argument, allowing to retrigger it at will. One of the values can be defined as a sustain point, meaning that as long as the gate is held, the envelope enters a sustain state when reaching this point. When the gate is set to 0, the envelope traverses the rest of the defined points. If the gate is closed before reaching the sustain segment, the envelope slides to the release section skipping any segments in between. Warning Unlike linsegr , linenv does not extend the time of the instrument. Use xtratim for that Note Similarly to linseg/linsegr, it is possible to define segments of 0 duration to force sharp jumps","title":"Description"},{"location":"opcodes/linenv.html#syntax","text":"xout linenv k gate , i sustindex , k val0 , [ k time1 , k val1 , k time2 , k val2 , ... ]","title":"Syntax"},{"location":"opcodes/linenv.html#arguments","text":"kgate : whenever this switches from 0 to 1 a new envelope starts. If a sustain segment was defined, when closing the gate (transition from 1 to 0) the envelope jumps to the sustain segment. Otherwise it just continues until it reaches the last segment (a \"oneshot\" envelope) isustindex : the index of the sustain point. For example, if isustindex is 2, then when the envelope reaches kval2 (after ktime0+ktime1), it enters a sustain phase, where its value remains unmodified until the gate is set to 0. If no sustain point is desired, set isustindex to 0. NB : negative values count from end. To imitate the behaviour of linsegr, use -1 as sustain index. kval0 , ktime1 , ...: a linear envelope, similar to linsegr . The release part can have as many segments as desired. ktime n values are defined as time interval between two values, not as absolute timestamps","title":"Arguments"},{"location":"opcodes/linenv.html#output","text":"xout : value of the envelope (k- or a- rate)","title":"Output"},{"location":"opcodes/linenv.html#execution-time","text":"Performance","title":"Execution Time"},{"location":"opcodes/linenv.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* This is the example file for opcode \"linenv\" linenv is a triggerable envelope with a sustain segment aout linenv kgate, isustidx, kval0, ktime1, kval1, ..., ktimen, kvaln NB: use xtratim if necessary to allow for release segment */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 gk gate init 0 FLpanel \"linenv\" , 240 , 100 , 100 , 100 gk gate , gi h1 FLbutton \" Gate\" , 1 , 0 , 2 , 80 , 40 , 10 , 10 , - 1 FLpanelEnd FLrun instr 1 k gate = trighold : k ( metro ( 1 / 2 ), 0.5 ) k env linenv k gate , 1 , 0 , 0.15 , 1 , 0.1 , 0 printf \"t: %f , kenv: %f \\n \" , timeinstk (), timeinsts (), k env k env *= 0.2 a sig = pinker () * interp ( k env ) outs a sig , a sig endin instr 2 i period = 2 i gatedur = 1 k gate = trighold : k ( metro ( 1 / i period ), i gatedur ) a env linenv k gate , - 2 , 0 , 0.05 , 1 , 0.2 , 0.5 , 0.2 , 1 , 0.4 , 0 a sig = oscili : a ( 0.2 , 1000 ) * a env FLsetVal changed ( k gate ), k gate , gi h1 outs a sig , a sig endin instr 3 a sig pinker a env linenv gk gate , 2 , 0 , 0.05 , 1 , 0.1 , 0.2 , 0.5 , 0 a sig *= a env outs a sig , a sig endin instr 4 ; no sustain (\"one shot\") a sig pinker a env linenv gk gate , 0 , 0 , 0.05 , 1 , 0.1 , 0.2 , 0.5 , 0 a sig *= a env outs a sig , a sig endin </ CsInstruments > < CsScore > ; i1 0 10 ; i2 0 10 i 3 0 100 ; i4 0 100 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/linenv.html#see-also","text":"ramptrig bisect interp1d bpf linsegr","title":"See also"},{"location":"opcodes/linenv.html#credits","text":"Eduardo Moguillansky, 2019 (idea based on pd/else's envgen and supercollider's envgen )","title":"Credits"},{"location":"opcodes/loadnpy.html","text":"loadnpy Abstract Load an array (of any number of dimensions) saved as a .npy file Description loadnpy loads an array saved as a .npy file. A .npy file holds a possibly multidimensional array of either int or float type, with members of 32 or 64 bits. This opcodes converts all such formats to a float array of the same shape. For more information on the .npy format, see https://numpy.org/devdocs/reference/generated/numpy.lib.format.html Syntax i Arr [] loadnpy S path k Arr [] loadnpy S path Arguments Spath : the path to the saved .npy file Output iArr / kArr : the data as an array. Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 i A [] loadnpy \"test-float64.npy\" printarray i A i B [] loadnpy \"test-2D.npy\" printarray i B i C [] loadnpy \"test-int.npy\" printarray i C turnoff endin </ CsInstruments > < CsScore > i 1 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer > See also ftgen fillarray ftnew ftfree Credits Eduardo Moguillansky, 2021","title":"loadnpy"},{"location":"opcodes/loadnpy.html#loadnpy","text":"","title":"loadnpy"},{"location":"opcodes/loadnpy.html#abstract","text":"Load an array (of any number of dimensions) saved as a .npy file","title":"Abstract"},{"location":"opcodes/loadnpy.html#description","text":"loadnpy loads an array saved as a .npy file. A .npy file holds a possibly multidimensional array of either int or float type, with members of 32 or 64 bits. This opcodes converts all such formats to a float array of the same shape. For more information on the .npy format, see https://numpy.org/devdocs/reference/generated/numpy.lib.format.html","title":"Description"},{"location":"opcodes/loadnpy.html#syntax","text":"i Arr [] loadnpy S path k Arr [] loadnpy S path","title":"Syntax"},{"location":"opcodes/loadnpy.html#arguments","text":"Spath : the path to the saved .npy file","title":"Arguments"},{"location":"opcodes/loadnpy.html#output","text":"iArr / kArr : the data as an array.","title":"Output"},{"location":"opcodes/loadnpy.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/loadnpy.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 i A [] loadnpy \"test-float64.npy\" printarray i A i B [] loadnpy \"test-2D.npy\" printarray i B i C [] loadnpy \"test-int.npy\" printarray i C turnoff endin </ CsInstruments > < CsScore > i 1 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/loadnpy.html#see-also","text":"ftgen fillarray ftnew ftfree","title":"See also"},{"location":"opcodes/loadnpy.html#credits","text":"Eduardo Moguillansky, 2021","title":"Credits"},{"location":"opcodes/memview.html","text":"memview Abstract Create a view into a table or another array Description memview makes it possible to operate on a table as if it were an array (using any array opcode), or to operate on a slice of an array without copying the underlying memory. It can be used to efficiently read a slice of an existing array, operate on rows of a 2D matrix, etc. The underlying memory is shared between the source and the view for the duration of the event. Using the returned array as a left-side variable is not supported. This can result in reallocation/resizing of the array, which in this case is not allowed since the underlying memory does not belong to the array. Using it in this way results in undefined behaviour The same holds true for creating a view from a ftable and freeing the ftable during the lifetime of the view. Syntax i View [] memview i ft , [, i start = 0 , i end = 0 ] k View [] memview i Source [] [, i start = 0 , i end = 0 ] k View [] memview k Source [] [, i start = 0 , i end = 0 ] Arguments ift : the source ftable iSource[] / kSource[] : the source array istart : the start index of the view (default=0) iend : the end index of the view (non inclusive, default=end of the table / array) Output iView[] / kView[] : the array view Execution time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound - m0 - d </ CsOptions > < CsInstruments > /* memview Create a view into a table or another array iView[] memview ift, [, istart=0, iend=0] kView[] memview iSource[] [, istart=0, iend=0] kView[] memview kSource[] [, istart=0, iend=0] ift: the source ftable iSource[] / kSource[]: the source array istart: the start index of the view (default=0) iend: the end index of the view (non inclusive, default=end of the table / array) memview makes it possible to operate on a table as if it were an array, using any array opcode. It is also possible to take a slice from a different array without copying the underlying elements. It can be used to efficiently read a slice of an existing array, operate on rows of a 2D matrix, etc. The underlying memory is shared between the source and the view for the duration of the event. It is not supported to reuse the array as a left-side variable because that could incurr in reallocation / resizing, which in this case is not allowed since the underlying memory does not belong to the array. Using it in this way results in undefined behaviour. The same holds true for creating a view from a ftable and freeing the ftable during the lifetime of the view. */ gi tab ftgen 0 , 0 , 10 , - 2 , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 instr 1 i View [] memview gi tab prints \" \\n $$$$ Original array:\" printarray i View i View [ 2 ] = 20 i View *= 0.5 prints \" \\n $$$$ Modified array:\" printarray i View prints \" \\n $$$$ Source table should be modified as well \\n \" ftprint gi tab prints \"array length: %d \\n \" , lenarray ( i View ) turnoff endin instr 2 k View [] memview gi tab printf \" \\n $$$$ Original array:\" , 1 printarray k View k View [ 2 ] = 20 k View *= 0.5 printf \" \\n $$$$ Modified array:\" , 1 printarray k View printf \" \\n $$$$ Source table should be modified as well \\n \" , 1 ftprint gi tab , - 1 turnoff endin instr 3 i X [] fillarray 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 i Y [] memview i X , 5 k Z [] memview i X , 3 , 8 i Y *= 10 printarray i Y printarray i X printarray k Z turnoff endin instr 4 k X [] fillarray 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 k Y [] memview k X , 5 k Y *= 0.5 printarray k X printarray k Y turnoff endin </ CsInstruments > < CsScore > ; i1 0 1 ; i2 0 1 i 3 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer > See also copya2ftab slicearray tabrowlin ref deref Credits Eduado Moguillansky, 2019","title":"memview"},{"location":"opcodes/memview.html#memview","text":"","title":"memview"},{"location":"opcodes/memview.html#abstract","text":"Create a view into a table or another array","title":"Abstract"},{"location":"opcodes/memview.html#description","text":"memview makes it possible to operate on a table as if it were an array (using any array opcode), or to operate on a slice of an array without copying the underlying memory. It can be used to efficiently read a slice of an existing array, operate on rows of a 2D matrix, etc. The underlying memory is shared between the source and the view for the duration of the event. Using the returned array as a left-side variable is not supported. This can result in reallocation/resizing of the array, which in this case is not allowed since the underlying memory does not belong to the array. Using it in this way results in undefined behaviour The same holds true for creating a view from a ftable and freeing the ftable during the lifetime of the view.","title":"Description"},{"location":"opcodes/memview.html#syntax","text":"i View [] memview i ft , [, i start = 0 , i end = 0 ] k View [] memview i Source [] [, i start = 0 , i end = 0 ] k View [] memview k Source [] [, i start = 0 , i end = 0 ]","title":"Syntax"},{"location":"opcodes/memview.html#arguments","text":"ift : the source ftable iSource[] / kSource[] : the source array istart : the start index of the view (default=0) iend : the end index of the view (non inclusive, default=end of the table / array)","title":"Arguments"},{"location":"opcodes/memview.html#output","text":"iView[] / kView[] : the array view","title":"Output"},{"location":"opcodes/memview.html#execution-time","text":"Init","title":"Execution time"},{"location":"opcodes/memview.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound - m0 - d </ CsOptions > < CsInstruments > /* memview Create a view into a table or another array iView[] memview ift, [, istart=0, iend=0] kView[] memview iSource[] [, istart=0, iend=0] kView[] memview kSource[] [, istart=0, iend=0] ift: the source ftable iSource[] / kSource[]: the source array istart: the start index of the view (default=0) iend: the end index of the view (non inclusive, default=end of the table / array) memview makes it possible to operate on a table as if it were an array, using any array opcode. It is also possible to take a slice from a different array without copying the underlying elements. It can be used to efficiently read a slice of an existing array, operate on rows of a 2D matrix, etc. The underlying memory is shared between the source and the view for the duration of the event. It is not supported to reuse the array as a left-side variable because that could incurr in reallocation / resizing, which in this case is not allowed since the underlying memory does not belong to the array. Using it in this way results in undefined behaviour. The same holds true for creating a view from a ftable and freeing the ftable during the lifetime of the view. */ gi tab ftgen 0 , 0 , 10 , - 2 , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 instr 1 i View [] memview gi tab prints \" \\n $$$$ Original array:\" printarray i View i View [ 2 ] = 20 i View *= 0.5 prints \" \\n $$$$ Modified array:\" printarray i View prints \" \\n $$$$ Source table should be modified as well \\n \" ftprint gi tab prints \"array length: %d \\n \" , lenarray ( i View ) turnoff endin instr 2 k View [] memview gi tab printf \" \\n $$$$ Original array:\" , 1 printarray k View k View [ 2 ] = 20 k View *= 0.5 printf \" \\n $$$$ Modified array:\" , 1 printarray k View printf \" \\n $$$$ Source table should be modified as well \\n \" , 1 ftprint gi tab , - 1 turnoff endin instr 3 i X [] fillarray 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 i Y [] memview i X , 5 k Z [] memview i X , 3 , 8 i Y *= 10 printarray i Y printarray i X printarray k Z turnoff endin instr 4 k X [] fillarray 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 k Y [] memview k X , 5 k Y *= 0.5 printarray k X printarray k Y turnoff endin </ CsInstruments > < CsScore > ; i1 0 1 ; i2 0 1 i 3 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/memview.html#see-also","text":"copya2ftab slicearray tabrowlin ref deref","title":"See also"},{"location":"opcodes/memview.html#credits","text":"Eduado Moguillansky, 2019","title":"Credits"},{"location":"opcodes/panstereo.html","text":"panstereo Abstract Stereo signal balancer Description Equal power panning balances two channels. By panning from left (pos=0) to right (pos=1) you are decrementing the level of the left channel from 1 to 0 taking the square root of the linear scaling factor, while at the same time incrementing the level of the right channel from 0 to 1 using the same curve. In the center position (pos=0.5) this results in a level for both channels of sqrt(0.5) ( ~=0.707 or -3dB ). The output of panstereo remains a stereo signal. This is a port of Supercollider's Balance2 ugen. Note kpan is defined between 0 (left) and 1 (right) to make it coherent with opcodes like pan2 , which also use this range. This differs from the original implementation in Supercollider, which uses a pan value of -1 to 1. Notice that even if kpan is a scalar (k-) variable, it is interpolated internaly to prevent discontinuities (\"zipper\" noise). Syntax a outL , a outR panstereo a L , a R , k pan , k level = 1 Arguments aL : left input aR : right input kpan : panning position, between 0 (left) and 1 (right) klevel : control rate level input (defaults to 1) Output aoutL : left output aoutR : right output Execution Time Performance Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 opcode panst , aa , aak a 0 , a 1 , k pos xin a L , a R pan2 a 0 , k pos a L1 , a R1 pan2 a 1 , k pos a L += a L1 a R += a R1 xout a L , a R endop instr 1 a noise = pinker () * 0.5 a L = reson ( a noise , 2000 , 200 , 2 ) a R = reson ( a noise , 1000 , 200 , 2 ) ; aR oscili 0.1, 1000 k pan = lfo : k ( 0.5 , 0.1 ) + 0.5 println \"kpan: %.3f \" , k pan a L , a R panstereo a L , a R , k pan , 1 outs a L , a R endin instr 2 a noise = pinker () * 0.5 a L = reson ( a noise , 2000 , 10 , 2 ) a R = reson ( a noise , 400 , 10 , 2 ) ; aR oscili 0.1, 1000 k pan invalue \"pan\" a L , a R panstereo a L , a R , k pan , 1 outs a L , a R endin </ CsInstruments > < CsScore > i 2 0.1 100 </ CsScore > </ CsoundSynthesizer > < bsbPanel > < label > Widgets </ label > < objectName /> < x > 0 </ x > < y > 0 </ y > < w idth > 0 </ w idth > < height > 0 </ height > < visible > true </ visible > < uuid /> < bgcolor mode = \"nobackground\" > < r > 255 </ r > < g > 255 </ g > < b > 255 </ b > </ bgcolor > < bsbObject type = \"BSBKnob\" version = \"2\" > < objectName > pan </ objectName > < x > 32 </ x > < y > 10 </ y > < w idth > 200 </ w idth > < height > 200 </ height > < uuid > { 96 c 2 fd 58 - 8 a 8e-4 c 1 c - 9 be 9 - d33e4934e239 } </ uuid > < visible > true </ visible > < midichan > 0 </ midichan > < midicc > 0 </ midicc > < description /> < minimum > 0.00000000 </ minimum > < maximum > 1.00000000 </ maximum > < value > 0.55500000 </ value > < mode > lin </ mode > < mouseControl a ct = \"\" > continuous </ mouseControl > < resolution > 0.01000000 </ resolution > < randomizable group = \"0\" > f alse </ randomizable > < color > < r > 245 </ r > < g > 124 </ g > < b > 0 </ b > </ color > < textcolor ># 512900 </ textcolor > < border > 0 </ border > < borderColor ># 512900 </ borderColor > < showvalue > true </ showvalue > < f latstyle > true </ f latstyle > < i ntegerMode > f alse </ i ntegerMode > </ bsbObject > </ bsbPanel > < bsbPresets > </ bsbPresets > See also pan2 original implementation bpf Panning and Spatialization Credits Eduardo Moguillansky, 2021","title":"panstereo"},{"location":"opcodes/panstereo.html#panstereo","text":"","title":"panstereo"},{"location":"opcodes/panstereo.html#abstract","text":"Stereo signal balancer","title":"Abstract"},{"location":"opcodes/panstereo.html#description","text":"Equal power panning balances two channels. By panning from left (pos=0) to right (pos=1) you are decrementing the level of the left channel from 1 to 0 taking the square root of the linear scaling factor, while at the same time incrementing the level of the right channel from 0 to 1 using the same curve. In the center position (pos=0.5) this results in a level for both channels of sqrt(0.5) ( ~=0.707 or -3dB ). The output of panstereo remains a stereo signal. This is a port of Supercollider's Balance2 ugen. Note kpan is defined between 0 (left) and 1 (right) to make it coherent with opcodes like pan2 , which also use this range. This differs from the original implementation in Supercollider, which uses a pan value of -1 to 1. Notice that even if kpan is a scalar (k-) variable, it is interpolated internaly to prevent discontinuities (\"zipper\" noise).","title":"Description"},{"location":"opcodes/panstereo.html#syntax","text":"a outL , a outR panstereo a L , a R , k pan , k level = 1","title":"Syntax"},{"location":"opcodes/panstereo.html#arguments","text":"aL : left input aR : right input kpan : panning position, between 0 (left) and 1 (right) klevel : control rate level input (defaults to 1)","title":"Arguments"},{"location":"opcodes/panstereo.html#output","text":"aoutL : left output aoutR : right output","title":"Output"},{"location":"opcodes/panstereo.html#execution-time","text":"Performance","title":"Execution Time"},{"location":"opcodes/panstereo.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 opcode panst , aa , aak a 0 , a 1 , k pos xin a L , a R pan2 a 0 , k pos a L1 , a R1 pan2 a 1 , k pos a L += a L1 a R += a R1 xout a L , a R endop instr 1 a noise = pinker () * 0.5 a L = reson ( a noise , 2000 , 200 , 2 ) a R = reson ( a noise , 1000 , 200 , 2 ) ; aR oscili 0.1, 1000 k pan = lfo : k ( 0.5 , 0.1 ) + 0.5 println \"kpan: %.3f \" , k pan a L , a R panstereo a L , a R , k pan , 1 outs a L , a R endin instr 2 a noise = pinker () * 0.5 a L = reson ( a noise , 2000 , 10 , 2 ) a R = reson ( a noise , 400 , 10 , 2 ) ; aR oscili 0.1, 1000 k pan invalue \"pan\" a L , a R panstereo a L , a R , k pan , 1 outs a L , a R endin </ CsInstruments > < CsScore > i 2 0.1 100 </ CsScore > </ CsoundSynthesizer > < bsbPanel > < label > Widgets </ label > < objectName /> < x > 0 </ x > < y > 0 </ y > < w idth > 0 </ w idth > < height > 0 </ height > < visible > true </ visible > < uuid /> < bgcolor mode = \"nobackground\" > < r > 255 </ r > < g > 255 </ g > < b > 255 </ b > </ bgcolor > < bsbObject type = \"BSBKnob\" version = \"2\" > < objectName > pan </ objectName > < x > 32 </ x > < y > 10 </ y > < w idth > 200 </ w idth > < height > 200 </ height > < uuid > { 96 c 2 fd 58 - 8 a 8e-4 c 1 c - 9 be 9 - d33e4934e239 } </ uuid > < visible > true </ visible > < midichan > 0 </ midichan > < midicc > 0 </ midicc > < description /> < minimum > 0.00000000 </ minimum > < maximum > 1.00000000 </ maximum > < value > 0.55500000 </ value > < mode > lin </ mode > < mouseControl a ct = \"\" > continuous </ mouseControl > < resolution > 0.01000000 </ resolution > < randomizable group = \"0\" > f alse </ randomizable > < color > < r > 245 </ r > < g > 124 </ g > < b > 0 </ b > </ color > < textcolor ># 512900 </ textcolor > < border > 0 </ border > < borderColor ># 512900 </ borderColor > < showvalue > true </ showvalue > < f latstyle > true </ f latstyle > < i ntegerMode > f alse </ i ntegerMode > </ bsbObject > </ bsbPanel > < bsbPresets > </ bsbPresets >","title":"Examples"},{"location":"opcodes/panstereo.html#see-also","text":"pan2 original implementation bpf Panning and Spatialization","title":"See also"},{"location":"opcodes/panstereo.html#credits","text":"Eduardo Moguillansky, 2021","title":"Credits"},{"location":"opcodes/pathAbsolute.html","text":"pathAbsolute Abstract Returns the absolute path of a file Description If a relative path is given as argument, pathAbsolute returns the absolute path relative to the current working directory. pathAbsolute will also expand ~ in unix platforms, so \"~/Documents/foo.txt\" will be expended to \"/home/<user>/Documents/foo.txt\" in linux and \"/Users/<user>/Documents/foo.txt\" in macOS. Other environmental variables are NOT expanded. Current working directory vs script directory Bear in mind that the current working directory is not necessarily the directory of the csd being run but the directory in which csound was started (either directly or via the API). To calculate the absolute path in relation to the directory of the script being run, see scriptDir . Syntax Sabspath pathAbsolute Spath Arguments `Spath': The path to a file or directory Output Sabspath : the absolute path Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* pathAbsolute Returns the absolute path of a file. */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 S path = \"/home/bar\" S abs = pathAbsolute ( S path ) prints \"Path: \\\" %s \\\" , Absolute Path: \\\" %s \\\" \\n \" , S path , S abs S path = \"foo/bar.ext\" S abs = pathAbsolute ( S path ) prints \"Path: \\\" %s \\\" , Absolute Path: \\\" %s \\\" \\n \" , S path , S abs S path = \" ~/Documents/mydoc.txt\" S abs = pathAbsolute ( S path ) prints \"Path: \\\" %s \\\" , Absolute Path: \\\" %s \\\" \\n \" , S path , S abs turnoff endin </ CsInstruments > < CsScore > i 1 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer > See also scriptDir pathJoin pathSplit Credits Eduardo Moguillansky, 2020","title":"pathAbsolute"},{"location":"opcodes/pathAbsolute.html#pathabsolute","text":"","title":"pathAbsolute"},{"location":"opcodes/pathAbsolute.html#abstract","text":"Returns the absolute path of a file","title":"Abstract"},{"location":"opcodes/pathAbsolute.html#description","text":"If a relative path is given as argument, pathAbsolute returns the absolute path relative to the current working directory. pathAbsolute will also expand ~ in unix platforms, so \"~/Documents/foo.txt\" will be expended to \"/home/<user>/Documents/foo.txt\" in linux and \"/Users/<user>/Documents/foo.txt\" in macOS. Other environmental variables are NOT expanded. Current working directory vs script directory Bear in mind that the current working directory is not necessarily the directory of the csd being run but the directory in which csound was started (either directly or via the API). To calculate the absolute path in relation to the directory of the script being run, see scriptDir .","title":"Description"},{"location":"opcodes/pathAbsolute.html#syntax","text":"Sabspath pathAbsolute Spath","title":"Syntax"},{"location":"opcodes/pathAbsolute.html#arguments","text":"`Spath': The path to a file or directory","title":"Arguments"},{"location":"opcodes/pathAbsolute.html#output","text":"Sabspath : the absolute path","title":"Output"},{"location":"opcodes/pathAbsolute.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/pathAbsolute.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* pathAbsolute Returns the absolute path of a file. */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 S path = \"/home/bar\" S abs = pathAbsolute ( S path ) prints \"Path: \\\" %s \\\" , Absolute Path: \\\" %s \\\" \\n \" , S path , S abs S path = \"foo/bar.ext\" S abs = pathAbsolute ( S path ) prints \"Path: \\\" %s \\\" , Absolute Path: \\\" %s \\\" \\n \" , S path , S abs S path = \" ~/Documents/mydoc.txt\" S abs = pathAbsolute ( S path ) prints \"Path: \\\" %s \\\" , Absolute Path: \\\" %s \\\" \\n \" , S path , S abs turnoff endin </ CsInstruments > < CsScore > i 1 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/pathAbsolute.html#see-also","text":"scriptDir pathJoin pathSplit","title":"See also"},{"location":"opcodes/pathAbsolute.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/pathIsAbsolute.html","text":"pathIsAbsolute Abstract Returns 1 if the path of a file is absolute Description Returns 1 if the path of a file is absolute Syntax i_isabsolute pathIsAbsolute Spath k_isabsolute pathIsAbsolute Spath Arguments `Spath': The path to a file or directory Output i_isabsolute : 1 if the path is absolute, 0 otherwise Execution Time Init (if the result is i-type) Perf (if the result is k-type) Examples i _isabsolute pathAbsolute \"relative/path/to/file.txt\" prints \"Path is absolute: %s \\n \" , i _isabsolute == 1 ? \"yes\" : \"no\" See also pathAbsolute scriptDir Credits Eduardo Moguillansky, 2020","title":"pathIsAbsolute"},{"location":"opcodes/pathIsAbsolute.html#pathisabsolute","text":"","title":"pathIsAbsolute"},{"location":"opcodes/pathIsAbsolute.html#abstract","text":"Returns 1 if the path of a file is absolute","title":"Abstract"},{"location":"opcodes/pathIsAbsolute.html#description","text":"Returns 1 if the path of a file is absolute","title":"Description"},{"location":"opcodes/pathIsAbsolute.html#syntax","text":"i_isabsolute pathIsAbsolute Spath k_isabsolute pathIsAbsolute Spath","title":"Syntax"},{"location":"opcodes/pathIsAbsolute.html#arguments","text":"`Spath': The path to a file or directory","title":"Arguments"},{"location":"opcodes/pathIsAbsolute.html#output","text":"i_isabsolute : 1 if the path is absolute, 0 otherwise","title":"Output"},{"location":"opcodes/pathIsAbsolute.html#execution-time","text":"Init (if the result is i-type) Perf (if the result is k-type)","title":"Execution Time"},{"location":"opcodes/pathIsAbsolute.html#examples","text":"i _isabsolute pathAbsolute \"relative/path/to/file.txt\" prints \"Path is absolute: %s \\n \" , i _isabsolute == 1 ? \"yes\" : \"no\"","title":"Examples"},{"location":"opcodes/pathIsAbsolute.html#see-also","text":"pathAbsolute scriptDir","title":"See also"},{"location":"opcodes/pathIsAbsolute.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/pathJoin.html","text":"pathJoin Abstract Join two parts of a path according to the current platform Description Given a directory and a filename, or a base directory and a relative path, join these according to the current platform Syntax Sout pathJoin Spath1, Spath2 Arguments Spath1 : The first part to join Spath2 : The second part to join Output Sout : the result of joining both paths Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 S dir = \"/home/bar\" S base = \"filename.ext\" S path = pathJoin ( S dir , S base ) prints \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base S dir = \"/home/bar/\" S base = \"filename.ext\" S path = pathJoin ( S dir , S base ) prints \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base S dir = \"\" S base = \"filename.ext\" S path = pathJoin ( S dir , S base ) prints \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base S dir = \"/home/bar\" S base = \"\" S path = pathJoin ( S dir , S base ) prints \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base turnoff endin </ CsInstruments > < CsScore > i 1 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer > See also pathSplit pathSplitExt Credits Eduardo Moguillansky, 2020","title":"pathJoin"},{"location":"opcodes/pathJoin.html#pathjoin","text":"","title":"pathJoin"},{"location":"opcodes/pathJoin.html#abstract","text":"Join two parts of a path according to the current platform","title":"Abstract"},{"location":"opcodes/pathJoin.html#description","text":"Given a directory and a filename, or a base directory and a relative path, join these according to the current platform","title":"Description"},{"location":"opcodes/pathJoin.html#syntax","text":"Sout pathJoin Spath1, Spath2","title":"Syntax"},{"location":"opcodes/pathJoin.html#arguments","text":"Spath1 : The first part to join Spath2 : The second part to join","title":"Arguments"},{"location":"opcodes/pathJoin.html#output","text":"Sout : the result of joining both paths","title":"Output"},{"location":"opcodes/pathJoin.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/pathJoin.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 S dir = \"/home/bar\" S base = \"filename.ext\" S path = pathJoin ( S dir , S base ) prints \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base S dir = \"/home/bar/\" S base = \"filename.ext\" S path = pathJoin ( S dir , S base ) prints \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base S dir = \"\" S base = \"filename.ext\" S path = pathJoin ( S dir , S base ) prints \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base S dir = \"/home/bar\" S base = \"\" S path = pathJoin ( S dir , S base ) prints \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base turnoff endin </ CsInstruments > < CsScore > i 1 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/pathJoin.html#see-also","text":"pathSplit pathSplitExt","title":"See also"},{"location":"opcodes/pathJoin.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/pathNative.html","text":"pathNative Abstract Convert a path to its native version Description Convert a path to a native path by replacing path separators to the native separators ('/' in unix, '\\' in windows) This is only useful when passing paths to external processes which need an absolute, native path NB : do not use absolute paths when writing cross-platform paths, since it is not possible to convert an absolute unix path to an absolute windows path (because of windows use of drives) NB2 : windows already converts any forward slash to backwards slash, so as long as you use relative paths, there is no need to use this Syntax Snative pathNative Spath Arguments Spath : the path to convert Output Snative : the native path Execution Time Init Examples S path = \"foo/bar/baz.txt\" S native pathNative S path prints \"Original: %s , Native version: %s \\n \" , S path , S native ; this should print the original in unix, \"foo\\bar\\baz.txt\" in windows See also pathNative Credits Eduardo Moguillansky, 2020","title":"pathNative"},{"location":"opcodes/pathNative.html#pathnative","text":"","title":"pathNative"},{"location":"opcodes/pathNative.html#abstract","text":"Convert a path to its native version","title":"Abstract"},{"location":"opcodes/pathNative.html#description","text":"Convert a path to a native path by replacing path separators to the native separators ('/' in unix, '\\' in windows) This is only useful when passing paths to external processes which need an absolute, native path NB : do not use absolute paths when writing cross-platform paths, since it is not possible to convert an absolute unix path to an absolute windows path (because of windows use of drives) NB2 : windows already converts any forward slash to backwards slash, so as long as you use relative paths, there is no need to use this","title":"Description"},{"location":"opcodes/pathNative.html#syntax","text":"Snative pathNative Spath","title":"Syntax"},{"location":"opcodes/pathNative.html#arguments","text":"Spath : the path to convert","title":"Arguments"},{"location":"opcodes/pathNative.html#output","text":"Snative : the native path","title":"Output"},{"location":"opcodes/pathNative.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/pathNative.html#examples","text":"S path = \"foo/bar/baz.txt\" S native pathNative S path prints \"Original: %s , Native version: %s \\n \" , S path , S native ; this should print the original in unix, \"foo\\bar\\baz.txt\" in windows","title":"Examples"},{"location":"opcodes/pathNative.html#see-also","text":"pathNative","title":"See also"},{"location":"opcodes/pathNative.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/pathSplit.html","text":"pathSplit Abstract Split a path into directory and basename Description Given a path /path/to/filename.txt , split it in /path/to and filename.txt . The directory part will never end with a path separator unless it is the root path Syntax Sdirectory, Sbase pathSplit Spath Arguments Spath : The path to split Output Sdirectory : the directory part of the path Sbase : the basename part of the path Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 S path = \"/home/bar/filename.ext\" S dir , S base pathSplit S path prints \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base S path = \"filename.ext\" S dir , S base pathSplit S path prints \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base S path = \"/filename.ext\" S dir , S base pathSplit S path prints \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base turnoff endin </ CsInstruments > < CsScore > i 1 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer > See also pathSplitk pathSplitExt pathSplitExtk Credits Eduardo Moguillansky, 2020","title":"pathSplit"},{"location":"opcodes/pathSplit.html#pathsplit","text":"","title":"pathSplit"},{"location":"opcodes/pathSplit.html#abstract","text":"Split a path into directory and basename","title":"Abstract"},{"location":"opcodes/pathSplit.html#description","text":"Given a path /path/to/filename.txt , split it in /path/to and filename.txt . The directory part will never end with a path separator unless it is the root path","title":"Description"},{"location":"opcodes/pathSplit.html#syntax","text":"Sdirectory, Sbase pathSplit Spath","title":"Syntax"},{"location":"opcodes/pathSplit.html#arguments","text":"Spath : The path to split","title":"Arguments"},{"location":"opcodes/pathSplit.html#output","text":"Sdirectory : the directory part of the path Sbase : the basename part of the path","title":"Output"},{"location":"opcodes/pathSplit.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/pathSplit.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 S path = \"/home/bar/filename.ext\" S dir , S base pathSplit S path prints \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base S path = \"filename.ext\" S dir , S base pathSplit S path prints \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base S path = \"/filename.ext\" S dir , S base pathSplit S path prints \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base turnoff endin </ CsInstruments > < CsScore > i 1 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/pathSplit.html#see-also","text":"pathSplitk pathSplitExt pathSplitExtk","title":"See also"},{"location":"opcodes/pathSplit.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/pathSplitExt.html","text":"pathSplitExt Abstract Split a path into prefix and extension Description Given a path /path/to/filename.txt , split it in /path/to/filename and .txt . See pathSplitExtk for a performance time version Syntax Sprefix, Sext pathSplitExt Spath Arguments Spath : The path to split Output Sprefix : Everything before the extension Sext : the extension, beginning with a . Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 S path = \"/home/bar/filename.ext\" S 1 , S ext pathSplitExt S path prints \"Spath: \\\" %s \\\" , S1: \\\" %s \\\" , Sext: \\\" %s \\\"\\n \" , S path , S 1 , S ext S path = \"foo.filename.ext\" S 1 , S ext pathSplitExt S path prints \"Spath: \\\" %s \\\" , S1: \\\" %s \\\" , Sext: \\\" %s \\\"\\n \" , S path , S 1 , S ext S path = \"/filename.ext\" S 1 , S ext pathSplitExt S path prints \"Spath: \\\" %s \\\" , S1: \\\" %s \\\" , Sext: \\\" %s \\\"\\n \" , S path , S 1 , S ext turnoff endin </ CsInstruments > < CsScore > i 1 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer > See also pathSplitExtk pathSplit pathJoin Credits Eduardo Moguillansky, 2020","title":"pathSplitExt"},{"location":"opcodes/pathSplitExt.html#pathsplitext","text":"","title":"pathSplitExt"},{"location":"opcodes/pathSplitExt.html#abstract","text":"Split a path into prefix and extension","title":"Abstract"},{"location":"opcodes/pathSplitExt.html#description","text":"Given a path /path/to/filename.txt , split it in /path/to/filename and .txt . See pathSplitExtk for a performance time version","title":"Description"},{"location":"opcodes/pathSplitExt.html#syntax","text":"Sprefix, Sext pathSplitExt Spath","title":"Syntax"},{"location":"opcodes/pathSplitExt.html#arguments","text":"Spath : The path to split","title":"Arguments"},{"location":"opcodes/pathSplitExt.html#output","text":"Sprefix : Everything before the extension Sext : the extension, beginning with a .","title":"Output"},{"location":"opcodes/pathSplitExt.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/pathSplitExt.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 S path = \"/home/bar/filename.ext\" S 1 , S ext pathSplitExt S path prints \"Spath: \\\" %s \\\" , S1: \\\" %s \\\" , Sext: \\\" %s \\\"\\n \" , S path , S 1 , S ext S path = \"foo.filename.ext\" S 1 , S ext pathSplitExt S path prints \"Spath: \\\" %s \\\" , S1: \\\" %s \\\" , Sext: \\\" %s \\\"\\n \" , S path , S 1 , S ext S path = \"/filename.ext\" S 1 , S ext pathSplitExt S path prints \"Spath: \\\" %s \\\" , S1: \\\" %s \\\" , Sext: \\\" %s \\\"\\n \" , S path , S 1 , S ext turnoff endin </ CsInstruments > < CsScore > i 1 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/pathSplitExt.html#see-also","text":"pathSplitExtk pathSplit pathJoin","title":"See also"},{"location":"opcodes/pathSplitExt.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/pathSplitExtk.html","text":"pathSplitExtk Abstract Split a path into prefix and extension at performance time Description Given a path /path/to/filename.txt , split it in /path/to/filename and .txt . See pathSplitExt for an init-time only version Syntax Sprefix, Sext pathSplitExtk Spath Arguments Spath : The path to split Output Sprefix : Everything before the extension Sext : the extension, beginning with a . Execution Time Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 S path = \"/home/bar/filename.ext\" S 1 , S ext pathSplitExt S path prints \"Spath: \\\" %s \\\" , S1: \\\" %s \\\" , Sext: \\\" %s \\\"\\n \" , S path , S 1 , S ext S path = \"foo.filename.ext\" S 1 , S ext pathSplitExt S path prints \"Spath: \\\" %s \\\" , S1: \\\" %s \\\" , Sext: \\\" %s \\\"\\n \" , S path , S 1 , S ext S path = \"/filename.ext\" S 1 , S ext pathSplitExt S path prints \"Spath: \\\" %s \\\" , S1: \\\" %s \\\" , Sext: \\\" %s \\\"\\n \" , S path , S 1 , S ext turnoff endin </ CsInstruments > < CsScore > i 1 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer > See also pathSplitExt pathSplit pathJoin Credits Eduardo Moguillansky, 2020","title":"pathSplitExtk"},{"location":"opcodes/pathSplitExtk.html#pathsplitextk","text":"","title":"pathSplitExtk"},{"location":"opcodes/pathSplitExtk.html#abstract","text":"Split a path into prefix and extension at performance time","title":"Abstract"},{"location":"opcodes/pathSplitExtk.html#description","text":"Given a path /path/to/filename.txt , split it in /path/to/filename and .txt . See pathSplitExt for an init-time only version","title":"Description"},{"location":"opcodes/pathSplitExtk.html#syntax","text":"Sprefix, Sext pathSplitExtk Spath","title":"Syntax"},{"location":"opcodes/pathSplitExtk.html#arguments","text":"Spath : The path to split","title":"Arguments"},{"location":"opcodes/pathSplitExtk.html#output","text":"Sprefix : Everything before the extension Sext : the extension, beginning with a .","title":"Output"},{"location":"opcodes/pathSplitExtk.html#execution-time","text":"Performance","title":"Execution Time"},{"location":"opcodes/pathSplitExtk.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 S path = \"/home/bar/filename.ext\" S 1 , S ext pathSplitExt S path prints \"Spath: \\\" %s \\\" , S1: \\\" %s \\\" , Sext: \\\" %s \\\"\\n \" , S path , S 1 , S ext S path = \"foo.filename.ext\" S 1 , S ext pathSplitExt S path prints \"Spath: \\\" %s \\\" , S1: \\\" %s \\\" , Sext: \\\" %s \\\"\\n \" , S path , S 1 , S ext S path = \"/filename.ext\" S 1 , S ext pathSplitExt S path prints \"Spath: \\\" %s \\\" , S1: \\\" %s \\\" , Sext: \\\" %s \\\"\\n \" , S path , S 1 , S ext turnoff endin </ CsInstruments > < CsScore > i 1 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/pathSplitExtk.html#see-also","text":"pathSplitExt pathSplit pathJoin","title":"See also"},{"location":"opcodes/pathSplitExtk.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/pathSplitk.html","text":"pathSplitk Abstract Split a path into directory and basename at perf-time Description Given a path /path/to/filename.txt , split it in /path/to and filename.txt . The directory part will never end with a path separator unless it is the root path Syntax Sdirectory, Sbase pathSplitk Spath Arguments Spath : The path to split Output Sdirectory : the directory part of the path Sbase : the basename part of the path Execution Time Performance Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 S path = \"/home/bar/filename.ext\" S dir , S base pathSplitk S path printsk \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base S path = \"filename.ext\" S dir , S base pathSplitk S path printsk \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base S path = \"/filename.ext\" S dir , S base pathSplitk S path printsk \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base turnoff endin </ CsInstruments > < CsScore > i 1 0 1 See also pathSplit pathSplitExt pathSplitExtk Credits Eduardo Moguillansky, 2020","title":"pathSplitk"},{"location":"opcodes/pathSplitk.html#pathsplitk","text":"","title":"pathSplitk"},{"location":"opcodes/pathSplitk.html#abstract","text":"Split a path into directory and basename at perf-time","title":"Abstract"},{"location":"opcodes/pathSplitk.html#description","text":"Given a path /path/to/filename.txt , split it in /path/to and filename.txt . The directory part will never end with a path separator unless it is the root path","title":"Description"},{"location":"opcodes/pathSplitk.html#syntax","text":"Sdirectory, Sbase pathSplitk Spath","title":"Syntax"},{"location":"opcodes/pathSplitk.html#arguments","text":"Spath : The path to split","title":"Arguments"},{"location":"opcodes/pathSplitk.html#output","text":"Sdirectory : the directory part of the path Sbase : the basename part of the path","title":"Output"},{"location":"opcodes/pathSplitk.html#execution-time","text":"Performance","title":"Execution Time"},{"location":"opcodes/pathSplitk.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 S path = \"/home/bar/filename.ext\" S dir , S base pathSplitk S path printsk \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base S path = \"filename.ext\" S dir , S base pathSplitk S path printsk \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base S path = \"/filename.ext\" S dir , S base pathSplitk S path printsk \"Spath: \\\" %s \\\" , Sdir: \\\" %s \\\" , Sbase: \\\" %s \\\"\\n \" , S path , S dir , S base turnoff endin </ CsInstruments > < CsScore > i 1 0 1","title":"Examples"},{"location":"opcodes/pathSplitk.html#see-also","text":"pathSplit pathSplitExt pathSplitExtk","title":"See also"},{"location":"opcodes/pathSplitk.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/perlin3.html","text":"perlin3 Abstract gradient noise sound generator Description Perlin noise is a type of gradient noise devised by Ken Perlin, and commonly used to add texture to objects rendered in computer graphics. It is deterministic: for a given input co-ordinate it always returns the same output value. To make audible noise you will typically need to define some trajectory through the co-ordinate space. perlin3 is a csound port of Supercollider's Perlin3 Syntax a out perlin3 a x , a y , a z k out perlin3 k x , k y , k z Arguments kx , ky , kz : the coordinates of a point in 3D space. In the current implementation the space wraps at 255 so any value is actually possible. Output aout / kout : the perlin noise corresponding to the given coordinates Execution Time Performance Examples < CsoundSynthesizer > < CsInstruments > /* to be run in csoundqt >= 0.9.8 */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ; an empty table to plot gi plot1 ftgen 0 , 0 , 1000 , 2 , 0 gi plot2 ftgen 0 , 0 , 1000 , 2 , 0 opcode tabplot , 0 , Sik S chan , i tab , k value xin outvalue S chan , i tab tablew k value , a ccum : k ( 1 ), i tab , 0 , 0 , 1 ; update the plot if metro ( 20 ) == 1 then outvalue S chan , k ( - 1 ) endif endop instr perlin3 k speed = line : k ( 1 , 10 , 4 ) a x = a ccum : a ( k speed / sr ) a z = a x * 0.5 a per1 = perlin3 ( a x , a ( 0 ), a z ) a per2 = perlin3 ( a ( 0 ), a x , a z ) a sig = pinker () * 0.4 ; remap to 0-1 a per1 = ( a per1 + 1 ) * 0.5 a per2 = ( a per2 + 1 ) * 0.5 i lagtime = 0.1 a 1 = a sig * lag ( a per1 , i lagtime ) a 2 = a sig * lag ( a per2 , i lagtime ) a 1 , a 2 reverbsc a 1 , a 2 , 0.92 , 12000 outch 1 , a 1 , 2 , a 2 ; plot the trajectory in csoundqt tabplot \"plot1\" , gi plot1 , a per1 [ 0 ] tabplot \"plot2\" , gi plot2 , a per2 [ 0 ] endin </ CsInstruments > < CsScore > i \"perlin3\" 0 300 </ CsScore > </ CsoundSynthesizer > < bsbPanel > < label > Widgets </ label > < objectName /> < x > 0 </ x > < y > 0 </ y > < w idth > 0 </ w idth > < height > 0 </ height > < visible > true </ visible > < uuid /> < bgcolor mode = \"nobackground\" > < r > 255 </ r > < g > 255 </ g > < b > 255 </ b > </ bgcolor > < bsbObject version = \"2\" type = \"BSBTableDisplay\" > < objectName > plot1 </ objectName > < x > 6 </ x > < y > 11 </ y > < w idth > 500 </ w idth > < height > 150 </ height > < uuid > { b75d16b1 - 05 b 3 - 4358 - 974 e - f 2dfa85d3d34 } </ uuid > < visible > true </ visible > < midichan > 0 </ midichan > < midicc >- 3 </ midicc > < description /> < color > < r > 255 </ r > < g > 193 </ g > < b > 3 </ b > </ color > < range > 0.00 </ range > </ bsbObject > < bsbObject version = \"2\" type = \"BSBTableDisplay\" > < objectName > plot2 </ objectName > < x > 5 </ x > < y > 170 </ y > < w idth > 500 </ w idth > < height > 150 </ height > < uuid > { 9 a 8 bac 1 d - 2234 - 450 c - 8807 - 37 f 9902 bfb 74 } </ uuid > < visible > true </ visible > < midichan > 0 </ midichan > < midicc >- 3 </ midicc > < description /> < color > < r > 255 </ r > < g > 193 </ g > < b > 3 </ b > </ color > < range > 0.00 </ range > </ bsbObject > </ bsbPanel > < bsbPresets > </ bsbPresets > See also Supercollider's Perlin3 Credits Eduardo Moguillansky, 2020","title":"perlin3"},{"location":"opcodes/perlin3.html#perlin3","text":"","title":"perlin3"},{"location":"opcodes/perlin3.html#abstract","text":"gradient noise sound generator","title":"Abstract"},{"location":"opcodes/perlin3.html#description","text":"Perlin noise is a type of gradient noise devised by Ken Perlin, and commonly used to add texture to objects rendered in computer graphics. It is deterministic: for a given input co-ordinate it always returns the same output value. To make audible noise you will typically need to define some trajectory through the co-ordinate space. perlin3 is a csound port of Supercollider's Perlin3","title":"Description"},{"location":"opcodes/perlin3.html#syntax","text":"a out perlin3 a x , a y , a z k out perlin3 k x , k y , k z","title":"Syntax"},{"location":"opcodes/perlin3.html#arguments","text":"kx , ky , kz : the coordinates of a point in 3D space. In the current implementation the space wraps at 255 so any value is actually possible.","title":"Arguments"},{"location":"opcodes/perlin3.html#output","text":"aout / kout : the perlin noise corresponding to the given coordinates","title":"Output"},{"location":"opcodes/perlin3.html#execution-time","text":"Performance","title":"Execution Time"},{"location":"opcodes/perlin3.html#examples","text":"< CsoundSynthesizer > < CsInstruments > /* to be run in csoundqt >= 0.9.8 */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ; an empty table to plot gi plot1 ftgen 0 , 0 , 1000 , 2 , 0 gi plot2 ftgen 0 , 0 , 1000 , 2 , 0 opcode tabplot , 0 , Sik S chan , i tab , k value xin outvalue S chan , i tab tablew k value , a ccum : k ( 1 ), i tab , 0 , 0 , 1 ; update the plot if metro ( 20 ) == 1 then outvalue S chan , k ( - 1 ) endif endop instr perlin3 k speed = line : k ( 1 , 10 , 4 ) a x = a ccum : a ( k speed / sr ) a z = a x * 0.5 a per1 = perlin3 ( a x , a ( 0 ), a z ) a per2 = perlin3 ( a ( 0 ), a x , a z ) a sig = pinker () * 0.4 ; remap to 0-1 a per1 = ( a per1 + 1 ) * 0.5 a per2 = ( a per2 + 1 ) * 0.5 i lagtime = 0.1 a 1 = a sig * lag ( a per1 , i lagtime ) a 2 = a sig * lag ( a per2 , i lagtime ) a 1 , a 2 reverbsc a 1 , a 2 , 0.92 , 12000 outch 1 , a 1 , 2 , a 2 ; plot the trajectory in csoundqt tabplot \"plot1\" , gi plot1 , a per1 [ 0 ] tabplot \"plot2\" , gi plot2 , a per2 [ 0 ] endin </ CsInstruments > < CsScore > i \"perlin3\" 0 300 </ CsScore > </ CsoundSynthesizer > < bsbPanel > < label > Widgets </ label > < objectName /> < x > 0 </ x > < y > 0 </ y > < w idth > 0 </ w idth > < height > 0 </ height > < visible > true </ visible > < uuid /> < bgcolor mode = \"nobackground\" > < r > 255 </ r > < g > 255 </ g > < b > 255 </ b > </ bgcolor > < bsbObject version = \"2\" type = \"BSBTableDisplay\" > < objectName > plot1 </ objectName > < x > 6 </ x > < y > 11 </ y > < w idth > 500 </ w idth > < height > 150 </ height > < uuid > { b75d16b1 - 05 b 3 - 4358 - 974 e - f 2dfa85d3d34 } </ uuid > < visible > true </ visible > < midichan > 0 </ midichan > < midicc >- 3 </ midicc > < description /> < color > < r > 255 </ r > < g > 193 </ g > < b > 3 </ b > </ color > < range > 0.00 </ range > </ bsbObject > < bsbObject version = \"2\" type = \"BSBTableDisplay\" > < objectName > plot2 </ objectName > < x > 5 </ x > < y > 170 </ y > < w idth > 500 </ w idth > < height > 150 </ height > < uuid > { 9 a 8 bac 1 d - 2234 - 450 c - 8807 - 37 f 9902 bfb 74 } </ uuid > < visible > true </ visible > < midichan > 0 </ midichan > < midicc >- 3 </ midicc > < description /> < color > < r > 255 </ r > < g > 193 </ g > < b > 3 </ b > </ color > < range > 0.00 </ range > </ bsbObject > </ bsbPanel > < bsbPresets > </ bsbPresets >","title":"Examples"},{"location":"opcodes/perlin3.html#see-also","text":"Supercollider's Perlin3","title":"See also"},{"location":"opcodes/perlin3.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/pread.html","text":"pread Abstract Read pfield values from any active instrument instance Description pread can be used to query the pfield value of a running instance (possibly a fractional instrument number) of an instrument. Together with pwrite it can be used to establish a two-way communication between two running instances of any two instruments. It no instance is found that matches the given instrument number, the output value is set to inotfound . Behaviour If no matching instance is found, pread returns inotfound . Reporting starts at the moment a matching instance is found. To avoid a continuous search, set instrnum as negative number. In this case, a matching instance is searched only once, and, if not found, this opcode becomes a noop If an instance is found and stops, pread returns inotfound from the moment the instance stops and no new instance is searched. Syntax i value pread i nstrnum , i index , i notfound =- 1 k value pread i nstrnum , i index , i notfound =- 1 k value pread i nstrnum , k index , i notfound =- 1 i values [] pread i nstrnum , i indexes [], i notfound =- 1 k values [] pread i nstrnum , i indexes [], i notfound =- 1 Arguments instrnum (i): the (fractional) instrument number to modify iindex / kindex : the index of the pfield to read. inotfound : the value to return if instrnum is not found. To avoid misinterpretation, this value should be different than any expected value of the pfield Output ivalue / kvalue : the current value of the given pfield. Will be inotfound if no matching instance has been found. Execution Time Init (if output is of i-type) Performance (if output is of k-type) Examples < CsoundSynthesizer > < CsOptions > -- nosound - m0 </ CsOptions > < CsInstruments > /* Example file for pread ====================== ivalue pread instrnum, index [, inotfound=-1] kvalue pread instrnum, kindex [, inotfound=-1] pread reads a pfield value from an active instrument Returns inotfound if instrnum is not active Raises a performance error if index is out of range */ instr 1 prints \"instr 1. p4= %f , p5= %f \\n \" , p4 , p5 endin instr 2 i p1 = p4 i p4 pread i p1 , 4 prints \"Inside instr 2. Instance p1= %f , p4= %f \\n \" , i p1 , i p4 pwrite i p1 , 4 , i p4 * 2 turnoff endin instr 4 i p1 = p4 i index [] fillarray 4 , 5 i vals [] pread i p1 , i index prints \"Inside instr 4, reading p4 and p5 as array\" printarray i vals turnoff endin </ CsInstruments > < CsScore > i 1.01 0 2 44 45 i 2 1 0 1.01 i 4 1.5 0 1.01 </ CsScore > </ CsoundSynthesizer > See also pwrite pset p passign uniqinstance Credits Eduardo Moguillansky, 2019","title":"pread"},{"location":"opcodes/pread.html#pread","text":"","title":"pread"},{"location":"opcodes/pread.html#abstract","text":"Read pfield values from any active instrument instance","title":"Abstract"},{"location":"opcodes/pread.html#description","text":"pread can be used to query the pfield value of a running instance (possibly a fractional instrument number) of an instrument. Together with pwrite it can be used to establish a two-way communication between two running instances of any two instruments. It no instance is found that matches the given instrument number, the output value is set to inotfound .","title":"Description"},{"location":"opcodes/pread.html#behaviour","text":"If no matching instance is found, pread returns inotfound . Reporting starts at the moment a matching instance is found. To avoid a continuous search, set instrnum as negative number. In this case, a matching instance is searched only once, and, if not found, this opcode becomes a noop If an instance is found and stops, pread returns inotfound from the moment the instance stops and no new instance is searched.","title":"Behaviour"},{"location":"opcodes/pread.html#syntax","text":"i value pread i nstrnum , i index , i notfound =- 1 k value pread i nstrnum , i index , i notfound =- 1 k value pread i nstrnum , k index , i notfound =- 1 i values [] pread i nstrnum , i indexes [], i notfound =- 1 k values [] pread i nstrnum , i indexes [], i notfound =- 1","title":"Syntax"},{"location":"opcodes/pread.html#arguments","text":"instrnum (i): the (fractional) instrument number to modify iindex / kindex : the index of the pfield to read. inotfound : the value to return if instrnum is not found. To avoid misinterpretation, this value should be different than any expected value of the pfield","title":"Arguments"},{"location":"opcodes/pread.html#output","text":"ivalue / kvalue : the current value of the given pfield. Will be inotfound if no matching instance has been found.","title":"Output"},{"location":"opcodes/pread.html#execution-time","text":"Init (if output is of i-type) Performance (if output is of k-type)","title":"Execution Time"},{"location":"opcodes/pread.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound - m0 </ CsOptions > < CsInstruments > /* Example file for pread ====================== ivalue pread instrnum, index [, inotfound=-1] kvalue pread instrnum, kindex [, inotfound=-1] pread reads a pfield value from an active instrument Returns inotfound if instrnum is not active Raises a performance error if index is out of range */ instr 1 prints \"instr 1. p4= %f , p5= %f \\n \" , p4 , p5 endin instr 2 i p1 = p4 i p4 pread i p1 , 4 prints \"Inside instr 2. Instance p1= %f , p4= %f \\n \" , i p1 , i p4 pwrite i p1 , 4 , i p4 * 2 turnoff endin instr 4 i p1 = p4 i index [] fillarray 4 , 5 i vals [] pread i p1 , i index prints \"Inside instr 4, reading p4 and p5 as array\" printarray i vals turnoff endin </ CsInstruments > < CsScore > i 1.01 0 2 44 45 i 2 1 0 1.01 i 4 1.5 0 1.01 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/pread.html#see-also","text":"pwrite pset p passign uniqinstance","title":"See also"},{"location":"opcodes/pread.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/pwrite.html","text":"pwrite Abstract Modify pfield values of an active instrument instance Description pwrite can be used to modify the value of a pfield of a running instance (possibly a fractional instrument number). Dynamic pfields In order for pwrite to have any effect, the instrument in question should have an assignment of the sort kfreq = p5 . Behaviour A matching instance is searched at performance time, so that its behaviour can be controlled via if or timout statements. If no active instance is found, search is retried until a matching instance is found. To avoid retrying, set instrnum to a negative value. If the instance ceases to exist during another instrument is modifying its pfield values, nothing happens. pwrite notices that the instance is not active anymore and becomes a NOOP . Exact instance vs Broadcasting If instrnum is a fractional instrument number, pwrite will only affect the first instance matching this exact number. If instrnum is set to an integer number, pwrite will broadcast the changes to ALL instruments with the same integer number. Warning Setting a value of a pfield out of range will result in a performance error. Syntax pwrite i nstrnum : i , i ndex : i | k , value : i | k , [ i ndex2 , value2 , ... ] Arguments instrnum (init only): the (fractional) instrument number to modify index (i-, k-): the index of the pfield to modify. If kindex is 4, then p4 will be modified value (i-, k-): the new value of the given pfield Info Multiple index:value pairs can be modified simultaneously Execution Time Init (if index and value are i-values) Performance (if any index or value are k-variables) Examples < CsoundSynthesizer > < CsOptions > - odac - m0 </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr exit exitnow endin ;; Example 1. instr 2 creates and controls instr 1 instr 1 pset 0 , 0 , 0 , 40 , 50 k t timeinsts k 4 = p4 k 5 = p5 printf \"time: %.4f \\t instance: %.3f \\t p4: %f \\t p5: %f \\n \" , metro ( 20 ), k t , p1 , k 4 , k 5 endin instr 2 k val line 0 , p3 , 1 pwrite 1.01 , 4 , k val pwrite 1.02 , 5 , k val * 2 endin instr example1 schedule 1.01 , 0 , 4 , - 1 schedule 1.02 , 0 , 4 , - 1 schedule 2 , 1 , 1 schedule \"exit\" , 4 , - 1 turnoff endin ;----------------------------- ; Example 2, one instrument modulates another instr ex2_generator pset p1 , p2 , p3 , 0.5 , 1000 , 4000 , 0.1 k amp = p4 k freq = p5 k cutoff = p6 k resonance = p7 a saw vco2 , k amp , k freq a out moogladder2 , a saw , k cutoff , k resonance a out *= linsegr ( 0 , 0.1 , 1 , 0.1 , 0 ) outs a out , a out endin instr ex2_control i glissdur = p4 i num = nstrnum ( \"ex2_generator\" ) i num1 = i num + 0.001 i num2 = i num + 0.002 k freq1 linseg ntof ( \"4A\" ), i glissdur , ntof ( \"3A\" ) k freq2 linseg ntof ( \"4F\" ), i glissdur , ntof ( \"3F\" ) ; amp schedule i num1 , 0 , p3 , 0.2 schedule i num2 , 0 , p3 , 0.2 pwrite i num1 , 5 , k freq1 pwrite i num2 , 5 , k freq2 endin instr ex2_broadcast printf \"filter start \\n \" , 1 i num = nstrnum ( \"ex2_generator\" ) k cutoff linseg 4000 , p3 , 400 k resonance linseg 0.1 , p3 * 0.5 , 0.8 pwrite i num , 6 , k cutoff , 7 , k resonance endin instr example2 schedule \"ex2_control\" , 0 , 8 , 4 schedule \"ex2_broadcast\" , 4 , 4 schedule \"exit\" , 8.5 , - 1 turnoff endin ;; Uncomment as needed ; schedule \"example1\", 0, 1 schedule \"example2\" , 0 , 1 </ CsInstruments > < CsScore > </ CsScore > </ CsoundSynthesizer > See also pread pset p passign uniqinstance Credits Eduardo Moguillansky, 2019","title":"pwrite"},{"location":"opcodes/pwrite.html#pwrite","text":"","title":"pwrite"},{"location":"opcodes/pwrite.html#abstract","text":"Modify pfield values of an active instrument instance","title":"Abstract"},{"location":"opcodes/pwrite.html#description","text":"pwrite can be used to modify the value of a pfield of a running instance (possibly a fractional instrument number).","title":"Description"},{"location":"opcodes/pwrite.html#dynamic-pfields","text":"In order for pwrite to have any effect, the instrument in question should have an assignment of the sort kfreq = p5 .","title":"Dynamic pfields"},{"location":"opcodes/pwrite.html#behaviour","text":"A matching instance is searched at performance time, so that its behaviour can be controlled via if or timout statements. If no active instance is found, search is retried until a matching instance is found. To avoid retrying, set instrnum to a negative value. If the instance ceases to exist during another instrument is modifying its pfield values, nothing happens. pwrite notices that the instance is not active anymore and becomes a NOOP .","title":"Behaviour"},{"location":"opcodes/pwrite.html#exact-instance-vs-broadcasting","text":"If instrnum is a fractional instrument number, pwrite will only affect the first instance matching this exact number. If instrnum is set to an integer number, pwrite will broadcast the changes to ALL instruments with the same integer number. Warning Setting a value of a pfield out of range will result in a performance error.","title":"Exact instance vs Broadcasting"},{"location":"opcodes/pwrite.html#syntax","text":"pwrite i nstrnum : i , i ndex : i | k , value : i | k , [ i ndex2 , value2 , ... ]","title":"Syntax"},{"location":"opcodes/pwrite.html#arguments","text":"instrnum (init only): the (fractional) instrument number to modify index (i-, k-): the index of the pfield to modify. If kindex is 4, then p4 will be modified value (i-, k-): the new value of the given pfield Info Multiple index:value pairs can be modified simultaneously","title":"Arguments"},{"location":"opcodes/pwrite.html#execution-time","text":"Init (if index and value are i-values) Performance (if any index or value are k-variables)","title":"Execution Time"},{"location":"opcodes/pwrite.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac - m0 </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr exit exitnow endin ;; Example 1. instr 2 creates and controls instr 1 instr 1 pset 0 , 0 , 0 , 40 , 50 k t timeinsts k 4 = p4 k 5 = p5 printf \"time: %.4f \\t instance: %.3f \\t p4: %f \\t p5: %f \\n \" , metro ( 20 ), k t , p1 , k 4 , k 5 endin instr 2 k val line 0 , p3 , 1 pwrite 1.01 , 4 , k val pwrite 1.02 , 5 , k val * 2 endin instr example1 schedule 1.01 , 0 , 4 , - 1 schedule 1.02 , 0 , 4 , - 1 schedule 2 , 1 , 1 schedule \"exit\" , 4 , - 1 turnoff endin ;----------------------------- ; Example 2, one instrument modulates another instr ex2_generator pset p1 , p2 , p3 , 0.5 , 1000 , 4000 , 0.1 k amp = p4 k freq = p5 k cutoff = p6 k resonance = p7 a saw vco2 , k amp , k freq a out moogladder2 , a saw , k cutoff , k resonance a out *= linsegr ( 0 , 0.1 , 1 , 0.1 , 0 ) outs a out , a out endin instr ex2_control i glissdur = p4 i num = nstrnum ( \"ex2_generator\" ) i num1 = i num + 0.001 i num2 = i num + 0.002 k freq1 linseg ntof ( \"4A\" ), i glissdur , ntof ( \"3A\" ) k freq2 linseg ntof ( \"4F\" ), i glissdur , ntof ( \"3F\" ) ; amp schedule i num1 , 0 , p3 , 0.2 schedule i num2 , 0 , p3 , 0.2 pwrite i num1 , 5 , k freq1 pwrite i num2 , 5 , k freq2 endin instr ex2_broadcast printf \"filter start \\n \" , 1 i num = nstrnum ( \"ex2_generator\" ) k cutoff linseg 4000 , p3 , 400 k resonance linseg 0.1 , p3 * 0.5 , 0.8 pwrite i num , 6 , k cutoff , 7 , k resonance endin instr example2 schedule \"ex2_control\" , 0 , 8 , 4 schedule \"ex2_broadcast\" , 4 , 4 schedule \"exit\" , 8.5 , - 1 turnoff endin ;; Uncomment as needed ; schedule \"example1\", 0, 1 schedule \"example2\" , 0 , 1 </ CsInstruments > < CsScore > </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/pwrite.html#see-also","text":"pread pset p passign uniqinstance","title":"See also"},{"location":"opcodes/pwrite.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/ramptrig.html","text":"ramptrig Abstract A triggerable ramp between 0 and 1 Description ramptrig is a phasor between 0 and 1, with the difference that it stops after reaching its end point. Whenever it is triggered it rewinds to 0 and starts ramping to 1 in the given duration. A trigger detected whenever the value is possitive and higher than the previous value. Usage as envelope generator Together with bpf this can be used to emulate supercollider's Env and EnvGen , where ramptrig is used as a triggerable phasor, passed as an argument to bpf , which generates the envelope. See examples Syntax k out ramptrig k trig , k dur , k valuepost = 1 , k valuepre = 0 a out ramptrig k trig , k dir , k valuepost = 1 k out , k finished ramptrig k trig , k dur , k valuepost = 1 , k valuepre = 0 Arguments ktrig : whenever this is possitive and higher than last value, kout is rewinded to 0 kdur : the duration of the ramp ivaluepost : value when ramp reaches its end (default=1) ivaluepre : value previous to any trigger (default=0) Output kout : value of the ramp, between 0 and 1. It can also be ivaluepost or ivaluepre if these are set to any other value than the default kfinished : will be one whenever the ramp reaches its end value. Execution Time Performance Examples < CsoundSynthesizer > < CsOptions > </ CsOptions > < CsInstruments > ; This is the example file of ramptrig ; ramptrig is a triggerable ramp from 0 to 1 ; xout ramptrig xtrig, kdur sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ; Use Case #1: An envelope which can be retriggered instr 1 ; Duration of envelope k dur = 4 ; This is the gate, could be any irregular signal, midi, osc, etc. k trig metro 0.5 ; Whenever ktrig is possitive and higher than previous value, ; kx ramps from 0 to 1 in kdur seconds k x ramptrig k trig , k dur ; actual envelope k env bpf k x * k dur , 0 , 0 , 0.02 , 1 , k dur , 0 a sig oscili 0.2 , 1000 ; asig pinker a sig *= interp ( k env ) outs a sig , a sig endin ; Use Case #2: Use finished trigger to signal something instr 2 k trig metro 1 / 4 k trig delayk k trig , 0.5 i dur = 2 k phase , k finished1 ramptrig k trig , 2 printf \"finished! \\n \" , k finished1 k env bpf k phase * i dur , 0 , 0 , 0.5 , 1 , 0.8 , 0.5 , 1 , 1 , i dur , 0 a sig = pinker () * interp ( k env ) outs a sig , a sig endin </ CsInstruments > < CsScore > i 1 0 10 ; i2 0 12 ; i3 0 20 ; f0 3600 </ CsScore > </ CsoundSynthesizer > See also linenv trigphasor bpf Credits Eduardo Moguillansky, 2019","title":"ramptrig"},{"location":"opcodes/ramptrig.html#ramptrig","text":"","title":"ramptrig"},{"location":"opcodes/ramptrig.html#abstract","text":"A triggerable ramp between 0 and 1","title":"Abstract"},{"location":"opcodes/ramptrig.html#description","text":"ramptrig is a phasor between 0 and 1, with the difference that it stops after reaching its end point. Whenever it is triggered it rewinds to 0 and starts ramping to 1 in the given duration. A trigger detected whenever the value is possitive and higher than the previous value. Usage as envelope generator Together with bpf this can be used to emulate supercollider's Env and EnvGen , where ramptrig is used as a triggerable phasor, passed as an argument to bpf , which generates the envelope. See examples","title":"Description"},{"location":"opcodes/ramptrig.html#syntax","text":"k out ramptrig k trig , k dur , k valuepost = 1 , k valuepre = 0 a out ramptrig k trig , k dir , k valuepost = 1 k out , k finished ramptrig k trig , k dur , k valuepost = 1 , k valuepre = 0","title":"Syntax"},{"location":"opcodes/ramptrig.html#arguments","text":"ktrig : whenever this is possitive and higher than last value, kout is rewinded to 0 kdur : the duration of the ramp ivaluepost : value when ramp reaches its end (default=1) ivaluepre : value previous to any trigger (default=0)","title":"Arguments"},{"location":"opcodes/ramptrig.html#output","text":"kout : value of the ramp, between 0 and 1. It can also be ivaluepost or ivaluepre if these are set to any other value than the default kfinished : will be one whenever the ramp reaches its end value.","title":"Output"},{"location":"opcodes/ramptrig.html#execution-time","text":"Performance","title":"Execution Time"},{"location":"opcodes/ramptrig.html#examples","text":"< CsoundSynthesizer > < CsOptions > </ CsOptions > < CsInstruments > ; This is the example file of ramptrig ; ramptrig is a triggerable ramp from 0 to 1 ; xout ramptrig xtrig, kdur sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 ; Use Case #1: An envelope which can be retriggered instr 1 ; Duration of envelope k dur = 4 ; This is the gate, could be any irregular signal, midi, osc, etc. k trig metro 0.5 ; Whenever ktrig is possitive and higher than previous value, ; kx ramps from 0 to 1 in kdur seconds k x ramptrig k trig , k dur ; actual envelope k env bpf k x * k dur , 0 , 0 , 0.02 , 1 , k dur , 0 a sig oscili 0.2 , 1000 ; asig pinker a sig *= interp ( k env ) outs a sig , a sig endin ; Use Case #2: Use finished trigger to signal something instr 2 k trig metro 1 / 4 k trig delayk k trig , 0.5 i dur = 2 k phase , k finished1 ramptrig k trig , 2 printf \"finished! \\n \" , k finished1 k env bpf k phase * i dur , 0 , 0 , 0.5 , 1 , 0.8 , 0.5 , 1 , 1 , i dur , 0 a sig = pinker () * interp ( k env ) outs a sig , a sig endin </ CsInstruments > < CsScore > i 1 0 10 ; i2 0 12 ; i3 0 20 ; f0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/ramptrig.html#see-also","text":"linenv trigphasor bpf","title":"See also"},{"location":"opcodes/ramptrig.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/ref.html","text":"ref Abstract Get a reference to a variable Description ref and deref implement a mechanism to pass a reference to an array, allowing to share it across instruments, opcodes, etc. Refs are reference counted and deallocate themselves when out of scope and not being used by any object. It makes it possible to pass arrays by reference to user defined opcodes, allowing to modify an array in place, skip copying memory, etc. i X [] fillarray 0 , 1 , 2 , 3 , 4 i ref ref i X i Y [] deref i ref In the case above, iY shares the same memory as iX and any modification in one array will be visible in the other. Syntax i ref ref xArray , [ i extrarefs = 0 ] Arguments xArray : the array to be referenced iextrarefs : use this for the niche case where a reference is passed to an event scheduled at a point in time later that the end of the current event. Without this, the ref would go out of scope before the deref takes place. Any extra ref must be matched with an extra deref ( kArr[] deref iref, 1 ) Output iref : an integer identifying the reference handle. Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > ;; Example file for ref - deref sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 gi A [] fillarray 0 , 1000 , 2000 , 3000 ; Example 1: take a ref from an array, deref it to create a second view of it instr 1 ; a source array i X [] fillarray 0 , 10 , 20 , 30 , 40 ; create a ref of iXs, return the index i ref ref i X ; now iYs points to iXs i Y [] deref i ref printarray i Y , \"\" , \"instrument 1, iY\" i Z [] fillarray 0 , 1 , 3 , 5 , 7 ; create a ref, pass it to instr. 2 schedule 2 , 0 , 1 , ref ( i Z ) ; create another ref of iZ. In this case the event is scheduled ; in the future, so the source will not exist anymore when instr. 2 ; is scheduled. This should fail. schedule 2 , 1 , 1 , ref ( i Z ) turnoff endin instr 2 i ref = p4 if refvalid ( i ref ) == 1 then i Zs [] deref i ref printarray i Zs , \"\" , \"p1=2, iZs\" else prints \" \\n The reference has become invalid \\n \" endif turnoff endin ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; Example 2: extra references to keep array alive instr 3 ; create a source array k Xs [] fillarray 1 , 1 , 2 , 3 , 5 , 8 , 13 ; In order to bridge the time gap between the end of life of the source ; of a ref and the scheduled event where a deref is taken, it is possible ; to create a forward reference, a \"promise\" that one deref has been scheduled ; in the future. ; short lived event, ends before this event schedule 4 , 0 , 0.1 , ref ( k Xs ), 0 ; starts before we end, but survives us schedule 4 , p3 - 0.1 , 0.2 , ref ( k Xs ), 0 ; starts after we end, we need an extra reference schedule 4 , p3 + 1 , 0.1 , ref ( k Xs , 1 ), 1 defer \"prints\" , \" --- instr. 3 finished --- \\n \" endin instr 4 prints \"instr. 4 \\n \" k View [] deref p4 , p5 printarray k View defer \"prints\" , \" --- instr. 4 finished --- \\n \" ; At deinition time the memory of the `iView` array is marked as deallocated. ; The handle (a global structure created by the `ref` opcode) which owns the memory, ; is signaled that no other clients of this data are alive. It deallocates the ; original memory and frees itself endin ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; test: multiple derefs instr 5 i Xs [] fillarray 0 , 1 , 4 , 9 i ref ref i Xs i Ys [] deref i ref i Zs [] deref i ref printarray i Ys printarray i Zs i Xs [ 0 ] = 100 printarray i Zs turnoff endin ; test performance of pass-by-value vs pass-by-reference opcode arrayadd , i[] , i[]i ; pass by value in and out i In [], i x xin i Out [] = i In + i x xout i Out endop opcode arrayaddref , i[] , ii ; pass by ref in, by value out i ref , i x xin i In [] deref i ref i Out [] = i In + i x xout i Out endop opcode arrayadd_inplace , 0 , ii ; in place i ref , i x xin i In [] deref i ref i In += i x endop opcode arrayadd_byref_inout , 0 , iii ; pass by ref in and out i refin , i refout , i x xin i In [] deref i refin i Out [] deref i refout if lenarray ( i Out ) >= lenarray ( i In ) then i Out = i In + i x endif endop instr testUdoPerformance1 ; Here we test the performance gain of passing arrays by reference. ; Passing the input array by reference seems to produce a speedup of ~25%, i num = 10000 i Xs [] genarray 0 , i num i i = 0 i t0 rtclock while i i < 20 do i Ys [] arrayadd i Xs , 2.0 i i += 1 od i t1 rtclock prints \"Dur UDO pass by value = %.8f \\n \" , i t1 - i t0 i ref = ref ( i Xs ) i t0 rtclock i Y0 [] arrayaddref i ref , 0.1 i Y0 arrayaddref i ref , 0.2 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i t1 rtclock prints \"Dur UDO pass by ref input = %.8f \\n \" , i t1 - i t0 i Zs [] genarray 0 , i num i Out [] init lenarray ( i Zs ) i t0 rtclock i refZ = ref ( i Zs ) i refOut = ref ( i Out ) arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 i t1 rtclock prints \"Dur UDO pass by ref in and out= %.8f \\n \" , i t1 - i t0 ; printarray iOut endin instr 7 i In [] genarray 0 , 1000 i Out [] init lenarray ( i In ) arrayadd_byref_inout ref ( i In ), ref ( i Out ), 0.5 turnoff endin instr 8 ; test k arrays ; 1. A way to convert a i-array to a k-array by taking a reference i Xs [] genarray 0 , 99 k Xs [] deref ref ( i Xs ) k Xs [ 0 ] = timeinsts () printarray k Xs , metro ( 8 ) endin instr 9 ; we need genarray_i because otherwise kXs is not initialized at i-time k Xs [] genarray 0 , 9 i Xs [] deref ref ( k Xs ) i Xs += 10 printarray i Xs printarray k Xs turnoff endin ; schedule 1, 0, 1 ; schedule 3, 0, 1 ; schedule 5, 0, 0.1 schedule \"testUdoPerformance1\" , 0 , 0.1 ; schedule 8, 0, 4 </ CsInstruments > < CsScore > e 10 </ CsScore > </ CsoundSynthesizer > See also deref defer schedule event release Credits Eduardo Moguillansky, 2019","title":"ref"},{"location":"opcodes/ref.html#ref","text":"","title":"ref"},{"location":"opcodes/ref.html#abstract","text":"Get a reference to a variable","title":"Abstract"},{"location":"opcodes/ref.html#description","text":"ref and deref implement a mechanism to pass a reference to an array, allowing to share it across instruments, opcodes, etc. Refs are reference counted and deallocate themselves when out of scope and not being used by any object. It makes it possible to pass arrays by reference to user defined opcodes, allowing to modify an array in place, skip copying memory, etc. i X [] fillarray 0 , 1 , 2 , 3 , 4 i ref ref i X i Y [] deref i ref In the case above, iY shares the same memory as iX and any modification in one array will be visible in the other.","title":"Description"},{"location":"opcodes/ref.html#syntax","text":"i ref ref xArray , [ i extrarefs = 0 ]","title":"Syntax"},{"location":"opcodes/ref.html#arguments","text":"xArray : the array to be referenced iextrarefs : use this for the niche case where a reference is passed to an event scheduled at a point in time later that the end of the current event. Without this, the ref would go out of scope before the deref takes place. Any extra ref must be matched with an extra deref ( kArr[] deref iref, 1 )","title":"Arguments"},{"location":"opcodes/ref.html#output","text":"iref : an integer identifying the reference handle.","title":"Output"},{"location":"opcodes/ref.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/ref.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > ;; Example file for ref - deref sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 gi A [] fillarray 0 , 1000 , 2000 , 3000 ; Example 1: take a ref from an array, deref it to create a second view of it instr 1 ; a source array i X [] fillarray 0 , 10 , 20 , 30 , 40 ; create a ref of iXs, return the index i ref ref i X ; now iYs points to iXs i Y [] deref i ref printarray i Y , \"\" , \"instrument 1, iY\" i Z [] fillarray 0 , 1 , 3 , 5 , 7 ; create a ref, pass it to instr. 2 schedule 2 , 0 , 1 , ref ( i Z ) ; create another ref of iZ. In this case the event is scheduled ; in the future, so the source will not exist anymore when instr. 2 ; is scheduled. This should fail. schedule 2 , 1 , 1 , ref ( i Z ) turnoff endin instr 2 i ref = p4 if refvalid ( i ref ) == 1 then i Zs [] deref i ref printarray i Zs , \"\" , \"p1=2, iZs\" else prints \" \\n The reference has become invalid \\n \" endif turnoff endin ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; Example 2: extra references to keep array alive instr 3 ; create a source array k Xs [] fillarray 1 , 1 , 2 , 3 , 5 , 8 , 13 ; In order to bridge the time gap between the end of life of the source ; of a ref and the scheduled event where a deref is taken, it is possible ; to create a forward reference, a \"promise\" that one deref has been scheduled ; in the future. ; short lived event, ends before this event schedule 4 , 0 , 0.1 , ref ( k Xs ), 0 ; starts before we end, but survives us schedule 4 , p3 - 0.1 , 0.2 , ref ( k Xs ), 0 ; starts after we end, we need an extra reference schedule 4 , p3 + 1 , 0.1 , ref ( k Xs , 1 ), 1 defer \"prints\" , \" --- instr. 3 finished --- \\n \" endin instr 4 prints \"instr. 4 \\n \" k View [] deref p4 , p5 printarray k View defer \"prints\" , \" --- instr. 4 finished --- \\n \" ; At deinition time the memory of the `iView` array is marked as deallocated. ; The handle (a global structure created by the `ref` opcode) which owns the memory, ; is signaled that no other clients of this data are alive. It deallocates the ; original memory and frees itself endin ;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; test: multiple derefs instr 5 i Xs [] fillarray 0 , 1 , 4 , 9 i ref ref i Xs i Ys [] deref i ref i Zs [] deref i ref printarray i Ys printarray i Zs i Xs [ 0 ] = 100 printarray i Zs turnoff endin ; test performance of pass-by-value vs pass-by-reference opcode arrayadd , i[] , i[]i ; pass by value in and out i In [], i x xin i Out [] = i In + i x xout i Out endop opcode arrayaddref , i[] , ii ; pass by ref in, by value out i ref , i x xin i In [] deref i ref i Out [] = i In + i x xout i Out endop opcode arrayadd_inplace , 0 , ii ; in place i ref , i x xin i In [] deref i ref i In += i x endop opcode arrayadd_byref_inout , 0 , iii ; pass by ref in and out i refin , i refout , i x xin i In [] deref i refin i Out [] deref i refout if lenarray ( i Out ) >= lenarray ( i In ) then i Out = i In + i x endif endop instr testUdoPerformance1 ; Here we test the performance gain of passing arrays by reference. ; Passing the input array by reference seems to produce a speedup of ~25%, i num = 10000 i Xs [] genarray 0 , i num i i = 0 i t0 rtclock while i i < 20 do i Ys [] arrayadd i Xs , 2.0 i i += 1 od i t1 rtclock prints \"Dur UDO pass by value = %.8f \\n \" , i t1 - i t0 i ref = ref ( i Xs ) i t0 rtclock i Y0 [] arrayaddref i ref , 0.1 i Y0 arrayaddref i ref , 0.2 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i Y0 arrayaddref i ref , 0.3 i t1 rtclock prints \"Dur UDO pass by ref input = %.8f \\n \" , i t1 - i t0 i Zs [] genarray 0 , i num i Out [] init lenarray ( i Zs ) i t0 rtclock i refZ = ref ( i Zs ) i refOut = ref ( i Out ) arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 arrayadd_byref_inout i refZ , i refOut , 0.5 i t1 rtclock prints \"Dur UDO pass by ref in and out= %.8f \\n \" , i t1 - i t0 ; printarray iOut endin instr 7 i In [] genarray 0 , 1000 i Out [] init lenarray ( i In ) arrayadd_byref_inout ref ( i In ), ref ( i Out ), 0.5 turnoff endin instr 8 ; test k arrays ; 1. A way to convert a i-array to a k-array by taking a reference i Xs [] genarray 0 , 99 k Xs [] deref ref ( i Xs ) k Xs [ 0 ] = timeinsts () printarray k Xs , metro ( 8 ) endin instr 9 ; we need genarray_i because otherwise kXs is not initialized at i-time k Xs [] genarray 0 , 9 i Xs [] deref ref ( k Xs ) i Xs += 10 printarray i Xs printarray k Xs turnoff endin ; schedule 1, 0, 1 ; schedule 3, 0, 1 ; schedule 5, 0, 0.1 schedule \"testUdoPerformance1\" , 0 , 0.1 ; schedule 8, 0, 4 </ CsInstruments > < CsScore > e 10 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/ref.html#see-also","text":"deref defer schedule event release","title":"See also"},{"location":"opcodes/ref.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/refvalid.html","text":"refvalid Abstract Queries if a reference is valid Description ref and deref implement a mechanism to pass a reference to any object, allowing to share a variable across instruments, with opcodes, etc. A reference is a proxy to an axisting variable / array. A reference is reference counted and deallocates itself when it falls out of scope without being referenced by any object. Since a reference is just an integer, refvalid can be used to check if the given reference index corresponds to a valid reference Syntax i out refvalid i ref k out refvalid k ref Arguments iref / kout : an integer identifying the reference handle, as passed via ref Output \u00ecout / kout : 1 if the reference is valid, 0 otherwise Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > - m0 - d </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 k freq linseg 0 , p3 , 1 schedule 2 , 0 , p3 , ref ( k freq ) endin instr 2 if refvalid ( p4 ) == 1 then k freq = deref ( p4 ) else k freq = 1000 endif a sig vco2 0.2 , k freq schedule 3 , 0 , p3 , ref ( a sig ) endin instr 3 if refvalid ( p4 ) == 1 then a in deref p4 else a in = 0 endif a out lpf18 a in , 2000 , 0.9 , 0.2 outs a out , a out endin See also deref ref defer schedule event release Credits Eduardo Moguillansky, 2019","title":"refvalid"},{"location":"opcodes/refvalid.html#refvalid","text":"","title":"refvalid"},{"location":"opcodes/refvalid.html#abstract","text":"Queries if a reference is valid","title":"Abstract"},{"location":"opcodes/refvalid.html#description","text":"ref and deref implement a mechanism to pass a reference to any object, allowing to share a variable across instruments, with opcodes, etc. A reference is a proxy to an axisting variable / array. A reference is reference counted and deallocates itself when it falls out of scope without being referenced by any object. Since a reference is just an integer, refvalid can be used to check if the given reference index corresponds to a valid reference","title":"Description"},{"location":"opcodes/refvalid.html#syntax","text":"i out refvalid i ref k out refvalid k ref","title":"Syntax"},{"location":"opcodes/refvalid.html#arguments","text":"iref / kout : an integer identifying the reference handle, as passed via ref","title":"Arguments"},{"location":"opcodes/refvalid.html#output","text":"\u00ecout / kout : 1 if the reference is valid, 0 otherwise","title":"Output"},{"location":"opcodes/refvalid.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/refvalid.html#examples","text":"< CsoundSynthesizer > < CsOptions > - m0 - d </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 k freq linseg 0 , p3 , 1 schedule 2 , 0 , p3 , ref ( k freq ) endin instr 2 if refvalid ( p4 ) == 1 then k freq = deref ( p4 ) else k freq = 1000 endif a sig vco2 0.2 , k freq schedule 3 , 0 , p3 , ref ( a sig ) endin instr 3 if refvalid ( p4 ) == 1 then a in deref p4 else a in = 0 endif a out lpf18 a in , 2000 , 0.9 , 0.2 outs a out , a out endin","title":"Examples"},{"location":"opcodes/refvalid.html#see-also","text":"deref ref defer schedule event release","title":"See also"},{"location":"opcodes/refvalid.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/schmitt.html","text":"schmitt Abstract A schmitt trigger (a comparator with hysteresis). Description Implements a schmitt trigger, which is a comparator with hysteresis. Whenever the input is higher than khigh , output is 1 and stays 1 until input drops beneath klow . Output is 1 if the input is higher than khigh if signal is increasing Output is 0 if the input is lower than klow if signal is decreasing Note schmitt is particularly useful for implementing effects like a noise gate, to avoid fast opening and closing at the threshold. It can be further refined together with lagud to add attack / release times to the opening of the gate or with trighold to assure a minimum open time for the gate Port of pd/else's schmitt Syntax xout schmitt xin , k high , k low Arguments xin : input signal (k- or audio rate). The rate of xin must match the rate of xout khigh : high value of the comparator, output is 1 whenever input is higher than this klow : low value of the comparator, output is 0 whenever input is lower than this Output xout : output value of the comparator (0 or 1). Rate of xout is the same as xin Execution Time Performance (k or audio) Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 /* Example file for schmitt opcode aout schmitt ain, khigh, klow kout schmitt kin, khigh, klow schmitt is a schmitt trigger (a gate with hysteresis), out is 1 if higher than khigh, 0 if lower than klow */ FLpanel \"schmitt\" , 400 , 300 , 50 , 50 i disp1 FLvalue \"\" , 40 , 30 , 322 , 20 i disp2 FLvalue \"\" , 40 , 30 , 322 , 80 i disp3 FLvalue \"\" , 40 , 30 , 322 , 140 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk signal , gi h1 FLslider \"signal\" , - 1 , 1 , 0 , 1 , i disp1 , 300 , 30 , 20 , 20 gk low , gi h2 FLslider \"low\" , - 1 , 1 , 0 , 3 , i disp2 , 300 , 30 , 20 , 80 gk high , gi h3 FLslider \"high\" , - 1 , 1 , 0 , 3 , i disp3 , 300 , 30 , 20 , 140 k schmitt , gi h4 FLbutton \"out\" , 1 , 0 , 3 , 50 , 50 , 20 , 200 , - 1 FLpanelEnd FLrun FLsetVal_i - 0.5 , gi h2 FLsetVal_i 0.5 , gi h3 instr 1 a in oscili 1 , 0.25 a out schmitt a in , gk high , gk low k guitrig metro 24 FLsetVal k guitrig , k ( a in ), gi h1 FLsetVal k guitrig , k ( a out ), gi h4 endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer > See also lagud trighold Credits Eduardo Moguillansky, 2019","title":"schmitt"},{"location":"opcodes/schmitt.html#schmitt","text":"","title":"schmitt"},{"location":"opcodes/schmitt.html#abstract","text":"A schmitt trigger (a comparator with hysteresis).","title":"Abstract"},{"location":"opcodes/schmitt.html#description","text":"Implements a schmitt trigger, which is a comparator with hysteresis. Whenever the input is higher than khigh , output is 1 and stays 1 until input drops beneath klow . Output is 1 if the input is higher than khigh if signal is increasing Output is 0 if the input is lower than klow if signal is decreasing Note schmitt is particularly useful for implementing effects like a noise gate, to avoid fast opening and closing at the threshold. It can be further refined together with lagud to add attack / release times to the opening of the gate or with trighold to assure a minimum open time for the gate Port of pd/else's schmitt","title":"Description"},{"location":"opcodes/schmitt.html#syntax","text":"xout schmitt xin , k high , k low","title":"Syntax"},{"location":"opcodes/schmitt.html#arguments","text":"xin : input signal (k- or audio rate). The rate of xin must match the rate of xout khigh : high value of the comparator, output is 1 whenever input is higher than this klow : low value of the comparator, output is 0 whenever input is lower than this","title":"Arguments"},{"location":"opcodes/schmitt.html#output","text":"xout : output value of the comparator (0 or 1). Rate of xout is the same as xin","title":"Output"},{"location":"opcodes/schmitt.html#execution-time","text":"Performance (k or audio)","title":"Execution Time"},{"location":"opcodes/schmitt.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 /* Example file for schmitt opcode aout schmitt ain, khigh, klow kout schmitt kin, khigh, klow schmitt is a schmitt trigger (a gate with hysteresis), out is 1 if higher than khigh, 0 if lower than klow */ FLpanel \"schmitt\" , 400 , 300 , 50 , 50 i disp1 FLvalue \"\" , 40 , 30 , 322 , 20 i disp2 FLvalue \"\" , 40 , 30 , 322 , 80 i disp3 FLvalue \"\" , 40 , 30 , 322 , 140 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk signal , gi h1 FLslider \"signal\" , - 1 , 1 , 0 , 1 , i disp1 , 300 , 30 , 20 , 20 gk low , gi h2 FLslider \"low\" , - 1 , 1 , 0 , 3 , i disp2 , 300 , 30 , 20 , 80 gk high , gi h3 FLslider \"high\" , - 1 , 1 , 0 , 3 , i disp3 , 300 , 30 , 20 , 140 k schmitt , gi h4 FLbutton \"out\" , 1 , 0 , 3 , 50 , 50 , 20 , 200 , - 1 FLpanelEnd FLrun FLsetVal_i - 0.5 , gi h2 FLsetVal_i 0.5 , gi h3 instr 1 a in oscili 1 , 0.25 a out schmitt a in , gk high , gk low k guitrig metro 24 FLsetVal k guitrig , k ( a in ), gi h1 FLsetVal k guitrig , k ( a out ), gi h4 endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/schmitt.html#see-also","text":"lagud trighold","title":"See also"},{"location":"opcodes/schmitt.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/scriptDir.html","text":"scriptDir Abstract Get the directory of the loaded orc/csd file Description Get the directory of the loaded script (orc/csd). This is not necessarily the same as the current working directory (which can be queried via the opcode pwd ). The pwd points at the directory from which csound was launched, the script directory is always the directory of the script being run. For example, if csound is launched as: $ /home/foo/> csound subdir/myscript.csd The current working dir is /home/foo , whereas the script directory is /home/foo/subdir This is useful when communicating to another process which is not aware of csound's environment and needs an absolute path to some file relative to the script being run Syntax Spath scriptDir Arguments Output Spath : the path of the loaded script Execution Time Init Examples S path scriptDir prints \"The script is being run from this folder: %s \\n \" , S path See also pathAbsolute findFileInPath pwd Credits Eduardo Moguillansky, 2020","title":"scriptDir"},{"location":"opcodes/scriptDir.html#scriptdir","text":"","title":"scriptDir"},{"location":"opcodes/scriptDir.html#abstract","text":"Get the directory of the loaded orc/csd file","title":"Abstract"},{"location":"opcodes/scriptDir.html#description","text":"Get the directory of the loaded script (orc/csd). This is not necessarily the same as the current working directory (which can be queried via the opcode pwd ). The pwd points at the directory from which csound was launched, the script directory is always the directory of the script being run. For example, if csound is launched as: $ /home/foo/> csound subdir/myscript.csd The current working dir is /home/foo , whereas the script directory is /home/foo/subdir This is useful when communicating to another process which is not aware of csound's environment and needs an absolute path to some file relative to the script being run","title":"Description"},{"location":"opcodes/scriptDir.html#syntax","text":"Spath scriptDir","title":"Syntax"},{"location":"opcodes/scriptDir.html#arguments","text":"","title":"Arguments"},{"location":"opcodes/scriptDir.html#output","text":"Spath : the path of the loaded script","title":"Output"},{"location":"opcodes/scriptDir.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/scriptDir.html#examples","text":"S path scriptDir prints \"The script is being run from this folder: %s \\n \" , S path","title":"Examples"},{"location":"opcodes/scriptDir.html#see-also","text":"pathAbsolute findFileInPath pwd","title":"See also"},{"location":"opcodes/scriptDir.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/setslice.html","text":"setslice Abstract Set a slice of an array to a given value Description setslice sets the elements of an array or a slice of it to a given value. This operation is done in place. It is the equivalent of this code: array [ start : end : step ] = value Syntax setslice i Array [], i value [, i start = 0 , i end = 0 , i step = 1 ] setslice k Array [], k value [, k start = 0 , k end = 0 , k step = 1 ] setslice i Array [], i Source [], i start = 0 setslice k Array [], k Source [], k start = 0 setslice S Array [], S Source [], k start = 0 Arguments value : the value to set the elements to start : the start index of the slice. Defaults to 0 end : the end index of the slice. Defaults to 0 which means until the end of the slice step : the number of steps to jump between elements. Default to 1 (all elements in the slice) xSource[] : the array used as source. In this case, all elements of the source array are copied to the destination array (xArray) starting at the given offset Output Execution Time Init (if all arguments are of i type) Performance (if any argument is of k type) Examples i A [] fillarray 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 setslice i A , 0.5 ; will set all elements of iA to 0.5 printarray i A k B [] init 10 ; if the condition is met setslice will set the even indexes ; between 0 to 6 of kB to -1 if k value = 1 then setslice k B , - 1 , 0 , 6 , 2 endif if changed2 ( k B ) == 1 then printarray k B endif ; kB: -1, 0, -1, 0, -1, 0, 0, 0, 0, 0 See also ftset ftslice slicearray Credits Eduardo Moguillansky, 2020","title":"setslice"},{"location":"opcodes/setslice.html#setslice","text":"","title":"setslice"},{"location":"opcodes/setslice.html#abstract","text":"Set a slice of an array to a given value","title":"Abstract"},{"location":"opcodes/setslice.html#description","text":"setslice sets the elements of an array or a slice of it to a given value. This operation is done in place. It is the equivalent of this code: array [ start : end : step ] = value","title":"Description"},{"location":"opcodes/setslice.html#syntax","text":"setslice i Array [], i value [, i start = 0 , i end = 0 , i step = 1 ] setslice k Array [], k value [, k start = 0 , k end = 0 , k step = 1 ] setslice i Array [], i Source [], i start = 0 setslice k Array [], k Source [], k start = 0 setslice S Array [], S Source [], k start = 0","title":"Syntax"},{"location":"opcodes/setslice.html#arguments","text":"value : the value to set the elements to start : the start index of the slice. Defaults to 0 end : the end index of the slice. Defaults to 0 which means until the end of the slice step : the number of steps to jump between elements. Default to 1 (all elements in the slice) xSource[] : the array used as source. In this case, all elements of the source array are copied to the destination array (xArray) starting at the given offset","title":"Arguments"},{"location":"opcodes/setslice.html#output","text":"","title":"Output"},{"location":"opcodes/setslice.html#execution-time","text":"Init (if all arguments are of i type) Performance (if any argument is of k type)","title":"Execution Time"},{"location":"opcodes/setslice.html#examples","text":"i A [] fillarray 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 setslice i A , 0.5 ; will set all elements of iA to 0.5 printarray i A k B [] init 10 ; if the condition is met setslice will set the even indexes ; between 0 to 6 of kB to -1 if k value = 1 then setslice k B , - 1 , 0 , 6 , 2 endif if changed2 ( k B ) == 1 then printarray k B endif ; kB: -1, 0, -1, 0, -1, 0, 0, 0, 0, 0","title":"Examples"},{"location":"opcodes/setslice.html#see-also","text":"ftset ftslice slicearray","title":"See also"},{"location":"opcodes/setslice.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/sflistprograms.html","text":"sflistprograms Abstract List the available programs in a soundfont without loading the samples Description This opcode is very similar to fluidInfo . Given the path to a soundfont, it returns an array of strings, where each string has the form <bank>-<programnumber> <programname> where bank is the bank number, programnumber is the program number (or preset number, both names are often used), as passed to fluidProgramSelect or sfinstr . Syntax S programs [] sflistprograms S path Arguments Spath : the path to a soundfont (.sf2) file Output Sprograms : the list of available programs Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound - m0 </ CsOptions > < CsInstruments > instr 1 S programs [] sflistprograms \"violin.sf2\" printarray S programs turnoff endin /* Prints: \"000-000 Campbells Violin\", \"000-001 Campbells V Loop\", \"000-002 Cam's Violin Reverb\" \"000-003 Cam's Violin Panned\", \"000-004 Violin- Pan & Reverb\", \"000-005 Cams Violin- tinny\" \"000-006 Cams Violin-Vibrato\" */ </ CsInstruments > < CsScore > i 1 0 0.1 </ CsScore > </ CsoundSynthesizer > See also fluidInfo sfinstr Credits Eduardo Moguillansky, 2021","title":"sflistprograms"},{"location":"opcodes/sflistprograms.html#sflistprograms","text":"","title":"sflistprograms"},{"location":"opcodes/sflistprograms.html#abstract","text":"List the available programs in a soundfont without loading the samples","title":"Abstract"},{"location":"opcodes/sflistprograms.html#description","text":"This opcode is very similar to fluidInfo . Given the path to a soundfont, it returns an array of strings, where each string has the form <bank>-<programnumber> <programname> where bank is the bank number, programnumber is the program number (or preset number, both names are often used), as passed to fluidProgramSelect or sfinstr .","title":"Description"},{"location":"opcodes/sflistprograms.html#syntax","text":"S programs [] sflistprograms S path","title":"Syntax"},{"location":"opcodes/sflistprograms.html#arguments","text":"Spath : the path to a soundfont (.sf2) file","title":"Arguments"},{"location":"opcodes/sflistprograms.html#output","text":"Sprograms : the list of available programs","title":"Output"},{"location":"opcodes/sflistprograms.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/sflistprograms.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound - m0 </ CsOptions > < CsInstruments > instr 1 S programs [] sflistprograms \"violin.sf2\" printarray S programs turnoff endin /* Prints: \"000-000 Campbells Violin\", \"000-001 Campbells V Loop\", \"000-002 Cam's Violin Reverb\" \"000-003 Cam's Violin Panned\", \"000-004 Violin- Pan & Reverb\", \"000-005 Cams Violin- tinny\" \"000-006 Cams Violin-Vibrato\" */ </ CsInstruments > < CsScore > i 1 0 0.1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/sflistprograms.html#see-also","text":"fluidInfo sfinstr","title":"See also"},{"location":"opcodes/sflistprograms.html#credits","text":"Eduardo Moguillansky, 2021","title":"Credits"},{"location":"opcodes/sigmdrive.html","text":"sigmdrive Abstract Analog \"soft clipping\" distortion by applying non-linear transfer functions. Description sigmdrive simulates analog \"soft clipping\" by applying non-linear transfer functions. Two different sigmoid equations are implemented. mode 0 out = tanh ( in * drivefactor ) mode 1 if in > 0 -> out = 1.0 - pow(1. - in, drivefactor) if in <= 0 -> out = pow(1. + x, drivefactor) - 1.0 Syntax a out sigmdrive a in , xdrivefactor , k mode = 0 Arguments ain : the input audio signal xdrivefactor : a k- or a- value, normally greater than 1. A higher value implies more distortion kmode : the distortion mode. 0=tanh, 1=pow (see above) Output aout : the distorted audio Execution Time Performance (audio) Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* sigmdrive: a sigmoid distortion aout sigmdrive ain, kdrive, kmode=0 kdrive: how much distortion (range 0-1) kmode: 0 = tanh, 1 = pow */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 FLpanel \"sigmdrive\" , 400 , 200 , 50 , 50 i disp1 FLvalue \"\" , 50 , 30 , 322 , 20 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk drive , i drivehandle1 FLslider \"drive\" , 0 , 10 , 0 , 3 , i disp1 , 300 , 30 , 20 , 20 gk mode , i drivehandle2 FLbutton \"mode\" , 1 , 0 , 3 , 60 , 50 , 20 , 80 , - 1 FLpanelEnd FLrun instr 1 a in oscili 0.2 , 440 a out sigmdrive a in , port : k ( gk drive , 0.2 ), gk mode outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer > See also tubeharmonics distort1 tanh powershape Credits Eduardo Moguillansky, 2019 (based on pd/else's drive~ - https://github.com/porres/pd-else)","title":"sigmdrive"},{"location":"opcodes/sigmdrive.html#sigmdrive","text":"","title":"sigmdrive"},{"location":"opcodes/sigmdrive.html#abstract","text":"Analog \"soft clipping\" distortion by applying non-linear transfer functions.","title":"Abstract"},{"location":"opcodes/sigmdrive.html#description","text":"sigmdrive simulates analog \"soft clipping\" by applying non-linear transfer functions. Two different sigmoid equations are implemented.","title":"Description"},{"location":"opcodes/sigmdrive.html#mode-0","text":"out = tanh ( in * drivefactor )","title":"mode 0"},{"location":"opcodes/sigmdrive.html#mode-1","text":"if in > 0 -> out = 1.0 - pow(1. - in, drivefactor) if in <= 0 -> out = pow(1. + x, drivefactor) - 1.0","title":"mode 1"},{"location":"opcodes/sigmdrive.html#syntax","text":"a out sigmdrive a in , xdrivefactor , k mode = 0","title":"Syntax"},{"location":"opcodes/sigmdrive.html#arguments","text":"ain : the input audio signal xdrivefactor : a k- or a- value, normally greater than 1. A higher value implies more distortion kmode : the distortion mode. 0=tanh, 1=pow (see above)","title":"Arguments"},{"location":"opcodes/sigmdrive.html#output","text":"aout : the distorted audio","title":"Output"},{"location":"opcodes/sigmdrive.html#execution-time","text":"Performance (audio)","title":"Execution Time"},{"location":"opcodes/sigmdrive.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > /* sigmdrive: a sigmoid distortion aout sigmdrive ain, kdrive, kmode=0 kdrive: how much distortion (range 0-1) kmode: 0 = tanh, 1 = pow */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 FLpanel \"sigmdrive\" , 400 , 200 , 50 , 50 i disp1 FLvalue \"\" , 50 , 30 , 322 , 20 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk drive , i drivehandle1 FLslider \"drive\" , 0 , 10 , 0 , 3 , i disp1 , 300 , 30 , 20 , 20 gk mode , i drivehandle2 FLbutton \"mode\" , 1 , 0 , 3 , 60 , 50 , 20 , 80 , - 1 FLpanelEnd FLrun instr 1 a in oscili 0.2 , 440 a out sigmdrive a in , port : k ( gk drive , 0.2 ), gk mode outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/sigmdrive.html#see-also","text":"tubeharmonics distort1 tanh powershape","title":"See also"},{"location":"opcodes/sigmdrive.html#credits","text":"Eduardo Moguillansky, 2019 (based on pd/else's drive~ - https://github.com/porres/pd-else)","title":"Credits"},{"location":"opcodes/standardchaos.html","text":"standardchaos Abstract Standard map chaotic generator Description standardchaos is a chaotic generator, the sound is generated with the following difference equations; y[n] = (y[n-1] + k * sin(x[n-1])) % 2pi; x[n] = (x[n-1] + y[n]) % 2pi; out = (x[n] - pi) / pi Syntax a out standardchaos k rate , k k = 1 , i x = 0.5 , i y = 0 Arguments krate : from 0 to nyquist kk : a value for k in the above equation ix : initial value for x iy : initial value for y Output aout : audio output of the chaotic generator Execution Time Performance (audio) Examples < CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 /* Example file for standardchaos opcode aout standardchaos krate, kk, ix=0.5, iy=0 Standard map chaotic generator, the sound is generated with the difference equations; y[n] = (y[n-1] + k * sin(x[n-1])) % 2pi; x[n] = (x[n-1] + y[n]) % 2pi; out = (x[n] - pi) / pi; */ FLpanel \"standardchaos\" , 600 , 300 , 50 , 50 i disp1 FLvalue \"\" , 50 , 30 , 522 , 20 i disp2 FLvalue \"\" , 50 , 30 , 522 , 80 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk rate , gi h1 FLslider \"rate\" , 0 , 20000 , 0 , 3 , i disp1 , 500 , 30 , 20 , 20 gk k , gi h2 FLslider \"k\" , 0 , 10 , 0 , 3 , i disp2 , 500 , 30 , 20 , 80 FLpanelEnd FLrun FLsetVal_i 1618 , gi h1 FLsetVal_i 1 , gi h2 instr 1 i x = 0.5 i y = 1 i gain = 0.3 a out standardchaos gk rate , gk k , i x , i y a out *= i gain outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer > < bsbPanel > < label > Widgets </ label > < objectName /> < x > 100 </ x > < y > 100 </ y > < w idth > 320 </ w idth > < height > 240 </ height > < visible > true </ visible > < uuid /> < bgcolor mode = \"nobackground\" > < r > 255 </ r > < g > 255 </ g > < b > 255 </ b > </ bgcolor > </ bsbPanel > < bsbPresets > </ bsbPresets > See also crackle chuap dust2 Credits Eduardo Moguillansky, 2019 (based on pd/else's standard~ - https://github.com/porres/pd-else)","title":"standardchaos"},{"location":"opcodes/standardchaos.html#standardchaos","text":"","title":"standardchaos"},{"location":"opcodes/standardchaos.html#abstract","text":"Standard map chaotic generator","title":"Abstract"},{"location":"opcodes/standardchaos.html#description","text":"standardchaos is a chaotic generator, the sound is generated with the following difference equations; y[n] = (y[n-1] + k * sin(x[n-1])) % 2pi; x[n] = (x[n-1] + y[n]) % 2pi; out = (x[n] - pi) / pi","title":"Description"},{"location":"opcodes/standardchaos.html#syntax","text":"a out standardchaos k rate , k k = 1 , i x = 0.5 , i y = 0","title":"Syntax"},{"location":"opcodes/standardchaos.html#arguments","text":"krate : from 0 to nyquist kk : a value for k in the above equation ix : initial value for x iy : initial value for y","title":"Arguments"},{"location":"opcodes/standardchaos.html#output","text":"aout : audio output of the chaotic generator","title":"Output"},{"location":"opcodes/standardchaos.html#execution-time","text":"Performance (audio)","title":"Execution Time"},{"location":"opcodes/standardchaos.html#examples","text":"< CsoundSynthesizer > < CsOptions > - odac </ CsOptions > < CsInstruments > sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 /* Example file for standardchaos opcode aout standardchaos krate, kk, ix=0.5, iy=0 Standard map chaotic generator, the sound is generated with the difference equations; y[n] = (y[n-1] + k * sin(x[n-1])) % 2pi; x[n] = (x[n-1] + y[n]) % 2pi; out = (x[n] - pi) / pi; */ FLpanel \"standardchaos\" , 600 , 300 , 50 , 50 i disp1 FLvalue \"\" , 50 , 30 , 522 , 20 i disp2 FLvalue \"\" , 50 , 30 , 522 , 80 FLcolor 150 , 100 , 150 , 200 , 100 , 250 gk rate , gi h1 FLslider \"rate\" , 0 , 20000 , 0 , 3 , i disp1 , 500 , 30 , 20 , 20 gk k , gi h2 FLslider \"k\" , 0 , 10 , 0 , 3 , i disp2 , 500 , 30 , 20 , 80 FLpanelEnd FLrun FLsetVal_i 1618 , gi h1 FLsetVal_i 1 , gi h2 instr 1 i x = 0.5 i y = 1 i gain = 0.3 a out standardchaos gk rate , gk k , i x , i y a out *= i gain outs a out , a out endin </ CsInstruments > < CsScore > i 1 0 100 </ CsScore > </ CsoundSynthesizer > < bsbPanel > < label > Widgets </ label > < objectName /> < x > 100 </ x > < y > 100 </ y > < w idth > 320 </ w idth > < height > 240 </ height > < visible > true </ visible > < uuid /> < bgcolor mode = \"nobackground\" > < r > 255 </ r > < g > 255 </ g > < b > 255 </ b > </ bgcolor > </ bsbPanel > < bsbPresets > </ bsbPresets >","title":"Examples"},{"location":"opcodes/standardchaos.html#see-also","text":"crackle chuap dust2","title":"See also"},{"location":"opcodes/standardchaos.html#credits","text":"Eduardo Moguillansky, 2019 (based on pd/else's standard~ - https://github.com/porres/pd-else)","title":"Credits"},{"location":"opcodes/strjoin.html","text":"strjoin Abstract Concatenate any number of strings Description Join multiple strings, either as an array or as arguments. The separator is inserted in between each given strings. The results is returned as a new strings Syntax Sout strjoin Ssep, Sstrings[] Sout strjoin Ssep, Sstr1, Sstr2, ..., Sstrn Arguments Ssep : a string to be inserted between each given string Sstrings : an array of strings Output Sout : the joint strings Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Sout strjoin Ssep, Sstrings[] Join multiple strings into one */ instr 1 S parts [] strsplit \"This;is;a;string!\" , \";\" S joint strjoin \"--\" , S parts prints \"Result: ' %s ' \\n \" , S joint turnoff endin instr 2 S joint strjoin \", \" , \"This\" , \"is\" , \"a\" , \"string!\" prints \"Result 2: ' %s ' \\n \" , S joint turnoff endin </ CsInstruments > < CsScore > i 1 0 1 i 2 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer > See also strsplit strstrip strsub strindex pathSplit pathSplitExt Credits Eduardo Moguillansky, 2021","title":"strjoin"},{"location":"opcodes/strjoin.html#strjoin","text":"","title":"strjoin"},{"location":"opcodes/strjoin.html#abstract","text":"Concatenate any number of strings","title":"Abstract"},{"location":"opcodes/strjoin.html#description","text":"Join multiple strings, either as an array or as arguments. The separator is inserted in between each given strings. The results is returned as a new strings","title":"Description"},{"location":"opcodes/strjoin.html#syntax","text":"Sout strjoin Ssep, Sstrings[] Sout strjoin Ssep, Sstr1, Sstr2, ..., Sstrn","title":"Syntax"},{"location":"opcodes/strjoin.html#arguments","text":"Ssep : a string to be inserted between each given string Sstrings : an array of strings","title":"Arguments"},{"location":"opcodes/strjoin.html#output","text":"Sout : the joint strings","title":"Output"},{"location":"opcodes/strjoin.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/strjoin.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Sout strjoin Ssep, Sstrings[] Join multiple strings into one */ instr 1 S parts [] strsplit \"This;is;a;string!\" , \";\" S joint strjoin \"--\" , S parts prints \"Result: ' %s ' \\n \" , S joint turnoff endin instr 2 S joint strjoin \", \" , \"This\" , \"is\" , \"a\" , \"string!\" prints \"Result 2: ' %s ' \\n \" , S joint turnoff endin </ CsInstruments > < CsScore > i 1 0 1 i 2 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/strjoin.html#see-also","text":"strsplit strstrip strsub strindex pathSplit pathSplitExt","title":"See also"},{"location":"opcodes/strjoin.html#credits","text":"Eduardo Moguillansky, 2021","title":"Credits"},{"location":"opcodes/strsplit.html","text":"strsplit Abstract Split a string at a given separator Description Split a string into parts at a given separator. The separator is not included in any of the parts Syntax Sparts[] strsplit Sstring, Sseparator Arguments Sstring : The string to split Sseparator : the delimiter used to split the string Output Sparts : an array of strings, holding the parts. Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Sparts[] strsplit Sstring, Sseparator Split a string into parts at the given separator */ instr 1 S parts [] strsplit \"This;is;a;string!\" , \";\" printarray S parts S lines [] strsplit {{ Line 0 Line 1 Line 2 Line 3 Line 5}} , \" \\n \" printarray S lines turnoff endin </ CsInstruments > < CsScore > i 1 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer > See also strstrip strsub strindex pathSplit [O] pathSplitExt Credits Eduardo Moguillansky, 2021","title":"strsplit"},{"location":"opcodes/strsplit.html#strsplit","text":"","title":"strsplit"},{"location":"opcodes/strsplit.html#abstract","text":"Split a string at a given separator","title":"Abstract"},{"location":"opcodes/strsplit.html#description","text":"Split a string into parts at a given separator. The separator is not included in any of the parts","title":"Description"},{"location":"opcodes/strsplit.html#syntax","text":"Sparts[] strsplit Sstring, Sseparator","title":"Syntax"},{"location":"opcodes/strsplit.html#arguments","text":"Sstring : The string to split Sseparator : the delimiter used to split the string","title":"Arguments"},{"location":"opcodes/strsplit.html#output","text":"Sparts : an array of strings, holding the parts.","title":"Output"},{"location":"opcodes/strsplit.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/strsplit.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound </ CsOptions > < CsInstruments > /* Sparts[] strsplit Sstring, Sseparator Split a string into parts at the given separator */ instr 1 S parts [] strsplit \"This;is;a;string!\" , \";\" printarray S parts S lines [] strsplit {{ Line 0 Line 1 Line 2 Line 3 Line 5}} , \" \\n \" printarray S lines turnoff endin </ CsInstruments > < CsScore > i 1 0 1 ; f0 3600 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/strsplit.html#see-also","text":"strstrip strsub strindex pathSplit [O] pathSplitExt","title":"See also"},{"location":"opcodes/strsplit.html#credits","text":"Eduardo Moguillansky, 2021","title":"Credits"},{"location":"opcodes/sysPlatform.html","text":"sysPlatform Abstract Get a string description of the current system platform Description Possible values depending on the platform: * windows * linux * macos * android * unix For unknown platforms, this opcode returns an empty string Syntax Splatform sysPlatform Arguments Output Splatform : a string describing the current platform Execution Time Init Examples S platform sysPlatform prints \"Csound is runnign on platform: %s \\n \" , S platform See also pathNative Credits Eduardo Moguillansky, 2020","title":"sysPlatform"},{"location":"opcodes/sysPlatform.html#sysplatform","text":"","title":"sysPlatform"},{"location":"opcodes/sysPlatform.html#abstract","text":"Get a string description of the current system platform","title":"Abstract"},{"location":"opcodes/sysPlatform.html#description","text":"Possible values depending on the platform: * windows * linux * macos * android * unix For unknown platforms, this opcode returns an empty string","title":"Description"},{"location":"opcodes/sysPlatform.html#syntax","text":"Splatform sysPlatform","title":"Syntax"},{"location":"opcodes/sysPlatform.html#arguments","text":"","title":"Arguments"},{"location":"opcodes/sysPlatform.html#output","text":"Splatform : a string describing the current platform","title":"Output"},{"location":"opcodes/sysPlatform.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/sysPlatform.html#examples","text":"S platform sysPlatform prints \"Csound is runnign on platform: %s \\n \" , S platform","title":"Examples"},{"location":"opcodes/sysPlatform.html#see-also","text":"pathNative","title":"See also"},{"location":"opcodes/sysPlatform.html#credits","text":"Eduardo Moguillansky, 2020","title":"Credits"},{"location":"opcodes/throwerror.html","text":"throwerror Abstract Throws an error message at performance or init Description Use throwerror to stop the current event with a performance error. Alternatively throwerror can just issue a warning. Without a type, a performance error is thrown. Syntax throwerror Smessage throwerror Stype, Smessage Arguments Stype : one of \"error\", \"init\", \"warning\", \"info\". If absent, type defaults to \"error\" Smessage : the text message to show. Use sprintf / sprintfk to construct a message if needed Output Execution Time Init (if Stype == \"init\") Performance (otherwise) Examples if k midi > 128 then throwerror \"Received an invalid midi value, stopping current event\" endif See also Credits Eduardo Moguillansky, 2019","title":"throwerror"},{"location":"opcodes/throwerror.html#throwerror","text":"","title":"throwerror"},{"location":"opcodes/throwerror.html#abstract","text":"Throws an error message at performance or init","title":"Abstract"},{"location":"opcodes/throwerror.html#description","text":"Use throwerror to stop the current event with a performance error. Alternatively throwerror can just issue a warning. Without a type, a performance error is thrown.","title":"Description"},{"location":"opcodes/throwerror.html#syntax","text":"throwerror Smessage throwerror Stype, Smessage","title":"Syntax"},{"location":"opcodes/throwerror.html#arguments","text":"Stype : one of \"error\", \"init\", \"warning\", \"info\". If absent, type defaults to \"error\" Smessage : the text message to show. Use sprintf / sprintfk to construct a message if needed","title":"Arguments"},{"location":"opcodes/throwerror.html#output","text":"","title":"Output"},{"location":"opcodes/throwerror.html#execution-time","text":"Init (if Stype == \"init\") Performance (otherwise)","title":"Execution Time"},{"location":"opcodes/throwerror.html#examples","text":"if k midi > 128 then throwerror \"Received an invalid midi value, stopping current event\" endif","title":"Examples"},{"location":"opcodes/throwerror.html#see-also","text":"","title":"See also"},{"location":"opcodes/throwerror.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/uniqinstance.html","text":"uniqinstance Abstract Return an fractional instrument number which is not in use Description Given an integer instrument number, uniqinstance a fractional instrument number which is not active now and can be used as p1 for event , schedule or similar opcodes to create a unique instance of the given instrument Note This opcode DOES NOT create a new instance. It just returns an instr number which can be used to create one Syntax i nstrnum uniqinstance i nteger_instrnum i nstrnum uniqinstance S instrname Arguments integer_instrnum : the integer instrument number Sinstrname : the name of a named instrument Output instrnum : a fractional instrument number which is guaranteed not to be active at the moment Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound - m0 </ CsOptions > < CsInstruments > /* Example file for uniqinstance instrnum uniqinstance intinstr Returns a unique fractional instrument number which is not active at the moment and can be assigned to a new instance */ instr exit exitnow endin instr 1 ; generate new instances manually, to check that ; uniqinstance does not collide with existing instances ; scheduled via other means k counter init 0 k trig metro 20 if k trig == 1 then k counter += 1 k inst = 10 + k counter / 100 printsk \"kinst= %f \\n \" , k inst schedulek ( k inst , 0 , 1 ) endif endin instr 2 i nstrnum10 uniqinstance 10 prints \"Unique instance of 10= %f \\n \" , i nstrnum10 i nstrnum11 uniqinstance 11 , 1000 prints \"Unique instance of 11= %f \\n \" , i nstrnum11 turnoff endin instr 10 print p1 endin instr 11 print p1 endin instr example1 printf \">>>>>>>>>>>>>>>>>>> example1 \\n \" , 1 schedule 1 , 0 , 0.5 schedule 2 , 0.5 , 0.1 schedule 10.150 , 0 , 0.1 schedule 11 , 0 , 2 turnoff endin ; -------------------------------------- ; Test that instances get recycled instr example2 prints \">>>>>>>>>>>>>>>>>>> example2 \\n \" i 0 = 0 i step = 0.01 i maxinstances = 100 i dur = i step * i maxinstances while i 0 < 1000 do schedule \"scheduniq\" , i 0 * i step , i dur , 20 , i maxinstances i 0 += 1 od i maxdur = 2000 * i step + i dur turnoff endin instr scheduniq i num = p4 i max = p5 i num2 = uniqinstance ( i num , i max ) if i num2 < 0 then prints \"<<<<< Could not find unique instance >>>>> \\n \" else schedule i num2 , 0 , p3 prints \"active now= %d , inum= %f \\n \" , active ( i num ), i num2 endif turnoff endin instr 20 prints \"started %f \\n \" , p1 defer \"prints\" , \"finished %f \\n \" , p1 endin ; ----------------------- ; Text what happens if called with a non-existent instr instr example3 i num = uniqinstance ( 234 ) print i num turnoff endin </ CsInstruments > < CsScore > ; i \"example1\" 0 10 ; i \"example2\" 0 10 i \"example3\" 0 0.1 </ CsScore > </ CsoundSynthesizer > See also pread pset p passign nstrnum Credits Eduardo Moguillansky, 2019","title":"uniqinstance"},{"location":"opcodes/uniqinstance.html#uniqinstance","text":"","title":"uniqinstance"},{"location":"opcodes/uniqinstance.html#abstract","text":"Return an fractional instrument number which is not in use","title":"Abstract"},{"location":"opcodes/uniqinstance.html#description","text":"Given an integer instrument number, uniqinstance a fractional instrument number which is not active now and can be used as p1 for event , schedule or similar opcodes to create a unique instance of the given instrument Note This opcode DOES NOT create a new instance. It just returns an instr number which can be used to create one","title":"Description"},{"location":"opcodes/uniqinstance.html#syntax","text":"i nstrnum uniqinstance i nteger_instrnum i nstrnum uniqinstance S instrname","title":"Syntax"},{"location":"opcodes/uniqinstance.html#arguments","text":"integer_instrnum : the integer instrument number Sinstrname : the name of a named instrument","title":"Arguments"},{"location":"opcodes/uniqinstance.html#output","text":"instrnum : a fractional instrument number which is guaranteed not to be active at the moment","title":"Output"},{"location":"opcodes/uniqinstance.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/uniqinstance.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound - m0 </ CsOptions > < CsInstruments > /* Example file for uniqinstance instrnum uniqinstance intinstr Returns a unique fractional instrument number which is not active at the moment and can be assigned to a new instance */ instr exit exitnow endin instr 1 ; generate new instances manually, to check that ; uniqinstance does not collide with existing instances ; scheduled via other means k counter init 0 k trig metro 20 if k trig == 1 then k counter += 1 k inst = 10 + k counter / 100 printsk \"kinst= %f \\n \" , k inst schedulek ( k inst , 0 , 1 ) endif endin instr 2 i nstrnum10 uniqinstance 10 prints \"Unique instance of 10= %f \\n \" , i nstrnum10 i nstrnum11 uniqinstance 11 , 1000 prints \"Unique instance of 11= %f \\n \" , i nstrnum11 turnoff endin instr 10 print p1 endin instr 11 print p1 endin instr example1 printf \">>>>>>>>>>>>>>>>>>> example1 \\n \" , 1 schedule 1 , 0 , 0.5 schedule 2 , 0.5 , 0.1 schedule 10.150 , 0 , 0.1 schedule 11 , 0 , 2 turnoff endin ; -------------------------------------- ; Test that instances get recycled instr example2 prints \">>>>>>>>>>>>>>>>>>> example2 \\n \" i 0 = 0 i step = 0.01 i maxinstances = 100 i dur = i step * i maxinstances while i 0 < 1000 do schedule \"scheduniq\" , i 0 * i step , i dur , 20 , i maxinstances i 0 += 1 od i maxdur = 2000 * i step + i dur turnoff endin instr scheduniq i num = p4 i max = p5 i num2 = uniqinstance ( i num , i max ) if i num2 < 0 then prints \"<<<<< Could not find unique instance >>>>> \\n \" else schedule i num2 , 0 , p3 prints \"active now= %d , inum= %f \\n \" , active ( i num ), i num2 endif turnoff endin instr 20 prints \"started %f \\n \" , p1 defer \"prints\" , \"finished %f \\n \" , p1 endin ; ----------------------- ; Text what happens if called with a non-existent instr instr example3 i num = uniqinstance ( 234 ) print i num turnoff endin </ CsInstruments > < CsScore > ; i \"example1\" 0 10 ; i \"example2\" 0 10 i \"example3\" 0 0.1 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/uniqinstance.html#see-also","text":"pread pset p passign nstrnum","title":"See also"},{"location":"opcodes/uniqinstance.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/xtracycles.html","text":"xtracycles Abstract Returns the number of extra performance cycles for an event Description xtracycles returns the number of extra performance cycles of an event. An event can extend its scheduled duration via two mechanisms - either through opcodes like linsegr , which have a release segment, or explicitely through xtratim , which extends the duration of an event by a given time. Note xtracycles should be called after all other duration extending opcodes (like linsegr or xtratim). It works only at init. Info To calculate the extra time for an event, divide the number of cycles by kr ( extratime = xtracycles() / kr ) Syntax icycles xtracycles Arguments Output icycles : the number of extra performance cycles for this event Execution Time Init Examples < CsoundSynthesizer > < CsOptions > -- nosound - d - m0 </ CsOptions > < CsInstruments > /* ## Example file for xtracycles opcode. xtracycles returns the number of extra performance cycles of an event. An event can extend its scheduled duration via two mechanisms - either through opcodes like `linsegr`, which have a release segment, or explicitely through `xtratim`, which extends the duration of an event by a given time. `xtracycles` should be called after all other duration extending opcodes (like linsegr or xtratim). It works only at init. NB: to calculate the extra time for an event, divide the number of cycles by kr (extratime = xtracycles() / kr) ## Syntax icycles xtracycles ## Returns icycles - the number of extra performance cycles for this event */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 a env linsegr 0 , 0.1 , 1 , 0.5 , 0 i extratime = xtracycles () / kr prints \" \\n >>> extra time = %f (should be higher than 0.5) \\n\\n \" , i extratime endin </ CsInstruments > < CsScore > i 1 0 3 </ CsScore > </ CsoundSynthesizer > See also release xtratim defer Credits Eduardo Moguillansky, 2019","title":"xtracycles"},{"location":"opcodes/xtracycles.html#xtracycles","text":"","title":"xtracycles"},{"location":"opcodes/xtracycles.html#abstract","text":"Returns the number of extra performance cycles for an event","title":"Abstract"},{"location":"opcodes/xtracycles.html#description","text":"xtracycles returns the number of extra performance cycles of an event. An event can extend its scheduled duration via two mechanisms - either through opcodes like linsegr , which have a release segment, or explicitely through xtratim , which extends the duration of an event by a given time. Note xtracycles should be called after all other duration extending opcodes (like linsegr or xtratim). It works only at init. Info To calculate the extra time for an event, divide the number of cycles by kr ( extratime = xtracycles() / kr )","title":"Description"},{"location":"opcodes/xtracycles.html#syntax","text":"icycles xtracycles","title":"Syntax"},{"location":"opcodes/xtracycles.html#arguments","text":"","title":"Arguments"},{"location":"opcodes/xtracycles.html#output","text":"icycles : the number of extra performance cycles for this event","title":"Output"},{"location":"opcodes/xtracycles.html#execution-time","text":"Init","title":"Execution Time"},{"location":"opcodes/xtracycles.html#examples","text":"< CsoundSynthesizer > < CsOptions > -- nosound - d - m0 </ CsOptions > < CsInstruments > /* ## Example file for xtracycles opcode. xtracycles returns the number of extra performance cycles of an event. An event can extend its scheduled duration via two mechanisms - either through opcodes like `linsegr`, which have a release segment, or explicitely through `xtratim`, which extends the duration of an event by a given time. `xtracycles` should be called after all other duration extending opcodes (like linsegr or xtratim). It works only at init. NB: to calculate the extra time for an event, divide the number of cycles by kr (extratime = xtracycles() / kr) ## Syntax icycles xtracycles ## Returns icycles - the number of extra performance cycles for this event */ sr = 44100 ksmps = 64 nchnls = 2 0dbfs = 1 instr 1 a env linsegr 0 , 0.1 , 1 , 0.5 , 0 i extratime = xtracycles () / kr prints \" \\n >>> extra time = %f (should be higher than 0.5) \\n\\n \" , i extratime endin </ CsInstruments > < CsScore > i 1 0 3 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/xtracycles.html#see-also","text":"release xtratim defer","title":"See also"},{"location":"opcodes/xtracycles.html#credits","text":"Eduardo Moguillansky, 2019","title":"Credits"},{"location":"opcodes/zeroarray.html","text":"zeroarray Abstract Zero all elements in an array Description zeroarray sets all elements in an array to 0. Syntax zeroarray i Arr zeroarray k Arr zeroarray a Arr Arguments iArr / kArr / aArr : The array to zero Output Execution Time Init Performance Examples < CsoundSynthesizer > < CsOptions > ; -odac </ CsOptions > < CsInstruments > /* Description =========== zeroarr zeroes all elements in an array of any (numeric) kind Syntax ====== zeroarr karr zeroarr arr */ ksmps = 32 nchnls = 2 0dbfs = 1 ga buses [] init 4 instr 10 a sig vco2 0.1 , 1000 ga buses [ 0 ] = ga buses [ 0 ] + a sig endin instr 20 a sig = ga buses [ 0 ] outch 1 , a sig zeroarray ga buses endin </ CsInstruments > < CsScore > i 10 0 10 i 20 0 10 </ CsScore > </ CsoundSynthesizer > See also ftset setslice ftslice Credits Eduardo Moguillansky, 2021","title":"zeroarray"},{"location":"opcodes/zeroarray.html#zeroarray","text":"","title":"zeroarray"},{"location":"opcodes/zeroarray.html#abstract","text":"Zero all elements in an array","title":"Abstract"},{"location":"opcodes/zeroarray.html#description","text":"zeroarray sets all elements in an array to 0.","title":"Description"},{"location":"opcodes/zeroarray.html#syntax","text":"zeroarray i Arr zeroarray k Arr zeroarray a Arr","title":"Syntax"},{"location":"opcodes/zeroarray.html#arguments","text":"iArr / kArr / aArr : The array to zero","title":"Arguments"},{"location":"opcodes/zeroarray.html#output","text":"","title":"Output"},{"location":"opcodes/zeroarray.html#execution-time","text":"Init Performance","title":"Execution Time"},{"location":"opcodes/zeroarray.html#examples","text":"< CsoundSynthesizer > < CsOptions > ; -odac </ CsOptions > < CsInstruments > /* Description =========== zeroarr zeroes all elements in an array of any (numeric) kind Syntax ====== zeroarr karr zeroarr arr */ ksmps = 32 nchnls = 2 0dbfs = 1 ga buses [] init 4 instr 10 a sig vco2 0.1 , 1000 ga buses [ 0 ] = ga buses [ 0 ] + a sig endin instr 20 a sig = ga buses [ 0 ] outch 1 , a sig zeroarray ga buses endin </ CsInstruments > < CsScore > i 10 0 10 i 20 0 10 </ CsScore > </ CsoundSynthesizer >","title":"Examples"},{"location":"opcodes/zeroarray.html#see-also","text":"ftset setslice ftslice","title":"See also"},{"location":"opcodes/zeroarray.html#credits","text":"Eduardo Moguillansky, 2021","title":"Credits"}]}